{
  "enumerator": {
    "source": "const { JScript } = require('sc')\nconst { TypeName } = require('vbs')\n\nJScript.AddCode(`\nfunction enumerator ( collection ) {\n    return new Enumerator( collection )\n}`)\n\nconst toArray = ( col ) => {\n    let res = []\n    let Enum = JScript.Run( 'enumerator', col )\n    for (; !Enum.atEnd(); Enum.moveNext()) {\n        res.push( Enum.item() )\n    }\n    Enum.moveFirst()\n    return res\n}\n\nclass Enumerator {\n    construct( target, args ) {\n        const res = []\n        const e = JScript.Run( 'enumerator', args[0] )\n        for ( ; !e.atEnd(); e.moveNext() ) {\n            res.push( e.item() )\n        }\n        return res\n    }\n}\n\n\nclass Enumerators extends Array {\n    constructor( collection ) {\n        let res = []\n        if (TypeName( collection ) === 'Long') {\n            res = collection\n        } else {\n            res = toArray( collection )\n        }\n        super( ...res )\n\n        let i = 0\n        Object.defineProperties( this, {\n            moveNext: { value() { i++ } },\n            atEnd: { value() { return !( i < this.length ) } },\n            moveFirst: { value() { return ( i = 0 ) } },\n            item: { value(num) { return num != null ? this[ num ] : this[ i ] } }\n        } )\n    }\n    map( callback ) {\n        var T, A, k\n        if ( this == null ) {\n            throw new TypeError( 'this is null or not defined' )\n        }\n        var O = Object( this )\n        var len = O.length >>> 0\n        if ( typeof callback !== 'function' ) {\n            throw new TypeError(callback + ' is not a function' )\n        }\n        if ( arguments.length > 1) {\n            T = arguments[1]\n        }\n        A = new Array(len)\n        k = 0\n        while (k < len) {\n            var kValue, mappedValue\n            if ( k in O ) {\n                kValue = O[k]\n                mappedValue = callback.call(T, kValue, k, O)\n                A[k] = mappedValue\n            }\n            k++\n        }\n        return A\n    }\n    filter( func, thisArg ) {\n        'use strict'\n        if (\n            !(\n                ( typeof func === 'Function' || typeof func === 'function' ) &&\n                this\n            )\n        )\n            throw new TypeError()\n        var len = this.length >>> 0,\n            res = new Array( len ),\n            t = this,\n            c = 0,\n            i = -1\n        if ( thisArg === undefined ) {\n            while ( ++i !== len ) {\n                if (i in this) {\n                    if ( func( t[ i ], i, t ) ) {\n                        res[ c++ ] = t[ i ]\n                    }\n                }\n            }\n        } else {\n            while ( ++i !== len ) {\n                if ( i in this ) {\n                    if ( func.call( thisArg, t[ i ], i, t ) ) {\n                        res[ c++ ] = t[ i ]\n                    }\n                }\n            }\n        }\n        res.length = c\n        return res\n    }\n}\n\n\n\nEnumerator.Enumerator = Enumerators\n\nmodule.exports = Enumerator",
    "mapping": {},
    "name": null
  },
  "io": {
    "source": "const UTF8Encoding = WScript.CreateObject('System.Text.UTF8Encoding')\nconst ADODB = WScript.CreateObject('ADODB.Stream')\nconst DOMDocument = WScript.CreateObject('Msxml2.DOMDocument')\nconst SHIFT_JIS = 'Shift-JIS'\nconst UTF_8 = 'UTF-8'\nconst UTF_8BOM = 'UTF-8BOM'\nconst UTF_8N = 'UTF-8N'\nconst AD_TYPE_BINARY = 1\nconst AD_TYPE_TEXT = 2\nconst AD_SAVE_CREAE_OVER_WRITE = 2\n\nconst binary2UTF8 = ( binary ) => {\n    return UTF8Encoding.GetString( binary )\n}\n\nconst binary2SJIS = ( binary ) => {\n    let source = ''\n    try {\n        ADODB.Open()\n        ADODB.Type = AD_TYPE_BINARY\n        ADODB.Write(binary)\n        ADODB.Position = 0\n        ADODB.Type = AD_TYPE_TEXT\n        ADODB.Charset = SHIFT_JIS\n        source = ADODB.ReadText()\n    } catch (error) {\n        console.log( `error binary2SJIS ${ error }` )\n    } finally {\n        ADODB.Close()\n    }\n    return source\n}\n\nconst binary2Hex = ( binary ) => {\n    let hex = WScript.CreateObject('Msxml2.DOMDocument').createElement('hex')\n    hex.dataType = 'bin.hex'\n    hex.nodeTypedValue = binary\n    return hex.text\n}\n\nconst Hex2binary = ( text ) => {\n    let hex = WScript.CreateObject('Msxml2.DOMDocument').createElement('hex')\n    hex.dataType = 'bin.hex'\n    hex.text = text\n    return hex.nodeTypedValue\n}\n\nconst UTF82bynary = ( text ) => WScript.CreateObject( 'System.Text.UTF8Encoding' ).GetBytes_4( text )\n\nconst SJIS2binary = ( text ) => {\n    const stream = WScript.CreateObject( 'ADODB.Stream' )\n    stream.Open()\n    stream.Type = AD_TYPE_TEXT\n    stream.Charset = SHIFT_JIS\n    stream.WriteText( text )\n    stream.Position = 0\n    stream.Type = AD_TYPE_BINARY\n    const res = stream.Read()\n    stream.Close()\n    return res\n}\n\nconst ReadBinaryFile = ( path ) => {\n    let source = ''\n    try {\n        ADODB.Type = AD_TYPE_BINARY\n        ADODB.Open()\n        ADODB.LoadFromFile( path )\n        source = ADODB.Read()\n    } catch ( error ) {\n        console.log( `error ReadBinaryFile ${ error } ${ path }` )\n    } finally {\n        ADODB.Close()\n    }\n    return source\n}\n\nconst autoGuessEncode = ( binary ) => {\n    let hex = binary2Hex( binary )\n    if ( /^efbbbf.+/.test(hex) ) return UTF_8BOM\n    let hexes = []\n    for ( let i = 0; i < hex.length; i++ ) {\n        hexes.push( Number( `0x${ hex[i] }${ hex[i + 1] }` ) )\n        i++\n    }\n    let len = hexes.length\n    if ( len < 2 ) return UTF_8N\n    let sjis = 0\n    let utf8 = 0\n    for ( let i = 0; i < len - 2; i++ ) {\n        const hex1 = hexes[i]\n        const hex2 = hexes[i + 1]\n        const hex3 = hexes[i + 2]\n        if (\n            ( ( 0x81 <= hex1 && hex1 <= 0x9f ) || ( 0xe0 <= hex1 && hex1 <= 0xfc ) ) &&\n            ( (0x40 <= hex2 && hex2 <= 0x7e ) || ( 0x80 <= hex2 && hex2 <= 0xfc ) )\n        ) sjis += 2\n        if (0xc0 <= hex1 && hex1 <= 0xdf && (0x80 <= hex2 && hex2 <= 0xbf)) utf8 += 2\n        else if (\n            0xe0 <= hex1 &&\n            hex1 <= 0xef &&\n            (0x80 <= hex2 && hex2 <= 0xbf) &&\n            (0x80 <= hex3 && hex3 <= 0xbf)\n        ) {\n            utf8 += 3\n            i += 2\n        }\n        i++\n    }\n    return sjis > utf8 ? SHIFT_JIS : UTF_8N\n}\n\nconst read = ( filespec, enc ) => {\n    let binary = ReadBinaryFile( filespec )\n    let encode = enc || autoGuessEncode( binary )\n    if (encode.toLowerCase() === SHIFT_JIS.toLowerCase()) return binary2SJIS( binary )\n    if (encode.toLowerCase() === UTF_8BOM.toLowerCase() || encode.toLowerCase() === UTF_8.toLowerCase() ) {\n        return binary2UTF8( Hex2binary( binary2Hex( binary ).replace(/^efbbbf/, '') ) )\n    }\n    return binary2UTF8(binary)\n}\n\nconst write = ( filespec, text, enc ) => {\n    const ADODB = WScript.CreateObject('ADODB.Stream')\n    try {\n        ADODB.Type = AD_TYPE_TEXT\n        if ( enc == null ) ADODB.CharSet = enc = SHIFT_JIS\n        else if ( enc.toLowerCase() === UTF_8N.toLowerCase() ) ADODB.CharSet = UTF_8\n        else ADODB.CharSet = enc\n        ADODB.Open()\n        ADODB.WriteText( text )\n    if ( enc.toLowerCase() === UTF_8N.toLowerCase() ) {\n        ADODB.Position = 0\n        ADODB.Type = AD_TYPE_BINARY\n        ADODB.Position = 3\n        let bytes = ADODB.Read()\n        ADODB.Position = 0\n        ADODB.SetEOS()\n        ADODB.Write( bytes )\n    }\n        ADODB.SaveToFile( filespec, AD_SAVE_CREAE_OVER_WRITE )\n    } catch ( error ) {\n        return console.log( `failed to writing '${ filespec }'\\n${ error }`)\n    } finally {\n        ADODB.Close()\n    }\n    return `succeeded in writing '${ filespec }'`\n}\n\nconst win32Sep = '\\\\'\nconst posixSep = '/'\nconst toWin32Sep = ( path ) => path.split( posixSep ).join( win32Sep )\nconst toPosixSep = ( path ) => path.split( win32Sep ).join( posixSep )\nconst absolute = ( path ) => toPosixSep( FSO.GetAbsolutePathName( toWin32Sep( path ) ) )\nconst split = ( path ) => toPosixSep( path ).split( posixSep )\nconst join = ( ...paths ) => absolute( toWin32Sep( paths.reduce( ( acc, curr ) => `${ acc }${ win32Sep }${ curr }` ) ) )\nconst dirname = ( path ) => absolute( FSO.GetParentFolderName( toWin32Sep( path ) ) )\nconst fileExists = ( path ) => FSO.FileExists( toWin32Sep( path ) )\n\nmodule.exports = {\n    readFileSync: read,\n    writeFileSync: write,\n    autoGuessEncode,\n    win32Sep,\n    posixSep,\n    toWin32Sep,\n    toPosixSep,\n    absolute,\n    split,\n    join,\n    dirname,\n    fileExists,\n    ReadBinaryFile,\n    binary2UTF8,\n    binary2SJIS,\n    binary2Hex,\n    Hex2binary,\n    UTF82bynary,\n    SJIS2binary\n}\n\n",
    "mapping": {},
    "name": null
  },
  "log": {
    "source": "const log = ( code ) => {\n    let res = code()\n    switch ( true ) {\n        case typeof res === 'function' || res instanceof RegExp:\n            res = res.toString()\n            break\n        case res instanceof Date:\n            res = res.toISOString()\n            break\n        case res === ( function(){} )():\n            res = 'undefined'\n            break\n        case res === null:\n            res = null\n            break\n        default:\n            res = JSON.stringify( res, null, 2 )\n    }\n    const { highGreen: green } = console.ansi\n    console.log( code.toString() + green + ' // => ' + res )\n}\n\nmodule.exports = log",
    "mapping": {},
    "name": null
  },
  "sc": {
    "source": "\nconst ScriptControl = ( language ) => {\n    const sc = WScript.CreateObject( 'ScriptControl' )\n    sc.Language = language\n    return {\n        AddCode( code ) {\n            sc.AddCode( code )\n        },\n        Run( name, ...args ) {\n            return sc.run( name, ...args )\n        }\n    }\n}\n\nmodule.exports = {\n    JScript: ScriptControl( 'JScript' ),\n    VBScript: ScriptControl( 'VBScript' )\n}\n",
    "mapping": {},
    "name": null
  },
  "test": {
    "source": "\n    let depth = 0\n    let caption = []\n    let indent = \"\"\n    let rate = 4\n    let space = \" \"\n    let noop = ( () => {} )\n    let n = '\\n'\n\n    const heavyCheck = '\\u2714'\n\n    const {\n        highRed: red,\n        highGreen: green,\n        highYellow: yellow,\n        highMagenta: pink,\n        highBlack: gray } = console.ansi\n\n    const describe = ( title, fn ) => {\n        let s = depth ? '' : n\n        depth++\n        indent = space.repeat( depth * rate )\n        console.log( s + indent + title + n )\n        fn()\n        depth--\n    }\n\n    const it = ( message, fn ) => {\n        depth++\n        indent = space.repeat( depth * rate )\n        const printCode = ( code ) => {\n            let source = code.toString().split( '\\t' ).join( '    ' ).split( /\\r?\\n/ )\n            if ( source.length < 2 ) return `${ space.repeat( indent + rate ) }${ source[0] }`\n            source[0] = `${ source[ source.length - 1 ].match( /^\\s+/ )[0] }${ source[0] }`\n            const sp = source.map( v => v.match( /^\\s+/ )[0].length )\n            const min = Math.min.apply( null, sp )\n            return source.map( ( v ) => {\n                return `${ space.repeat( ( depth + 1 ) * rate ) }${ v.replace( space.repeat( min ), \"\"  ) }`\n            } ).join( \"\\n\" )\n        }\n\n        try {\n            fn()\n            console.log( `${ indent }${ gray }${ message } ${ green }${ heavyCheck }` )\n        } catch ( e ) {\n            console.log( `${ indent }${ pink }${ message }\\n${ yellow }${ printCode( fn ) } ${ red }// => ${ e.message }${ n }` )\n        } finally {\n            depth--\n        }\n    }\n\n    const assert = ( assertion ) => {\n        return assert.ok( assertion )\n    }\n    assert.ok = ( assertion ) => {\n        let res = typeof assertion === 'function' ? assertion() : assertion\n        if ( !res ) throw new Error( res )\n    }\n    assert.ng = ( assertion ) => {\n        let res = typeof assertion === 'function' ? assertion() : assertion\n        if ( res ) throw new Error( res )\n    }\n\n    module.exports = {\n        describe,\n        it,\n        assert\n    }\n\n\n\n",
    "mapping": {},
    "name": null
  },
  "vbs": {
    "source": "const { VBScript } = require( 'sc' )\n\nVBScript.AddCode(`\nFunction getTypeName( obj )\n    getTypeName = TypeName( obj )\nEnd Function\n`)\n\nVBScript.AddCode(`\nFunction getVarType( obj )\n    getVarType = VarType( obj )\nEnd Function\n`)\n\n\nconst TypeName = ( object ) => VBScript.Run( 'getTypeName', object )\nconst VarType = ( object ) => VBScript.Run( 'getVarType', object )\nconst Type = ( object ) => {\n    const constant = [\n        'vbEmpty', // 0\n        'vbNull', // 1\n        'vbInteger', // 2\n        'vbLong', // 3\n        'vbSingle', // 4\n        'vbDouble', // 5\n        'vbCurrency', // 6\n        'vbDate', // 7\n        'vbString', // 8\n        'vbObject', // 9\n        'vbError', // 10\n        'vbBoolean', // 11\n        'vbVariant', // 12\n        'vbDataObject', // 13\n    ]\n    let num = VarType( object )\n    return  num > 8192 ? `${ constant[ num - 8192 ] }[]` : constant[ num ]\n}\nType[17] = 'vbByte'\nType[8192] = 'vbArray'\n\nmodule.exports = {\n    TypeName,\n    VarType,\n    Type\n}\n",
    "mapping": {},
    "name": null
  }
}