{
    "enumerator": {
        "source": "const { JScript } = require('sc')\nconst { TypeName } = require('vbs')\nJScript.AddCode(`\nfunction enumerator ( collection ) {\nreturn new Enumerator( collection )\n}`)\nconst toArray = ( col ) => {\nlet res = []\nlet Enum = JScript.Run( 'enumerator', col )\nfor (; !Enum.atEnd(); Enum.moveNext()) {\nres.push( Enum.item() )\n}\nEnum.moveFirst()\nreturn res\n}\nconst Enumerator = new Proxy( () => {},{\nconstruct( target, args ) {\nconst res = []\nconst e = JScript.Run( 'enumerator', args[0] )\nfor ( ; !e.atEnd(); e.moveNext() ) {\nres.push( e.item() )\n}\nreturn res\n}\n} )\nclass Enumerators extends Array {\nconstructor( collection ) {\nlet res = []\nif (TypeName( collection ) === 'Long') {\nres = collection\n} else {\nres = toArray( collection )\n}\nsuper( ...res )\nlet i = 0\nObject.defineProperties( this, {\nmoveNext: { value() { i++ } },\natEnd: { value() { return !( i < this.length ) } },\nmoveFirst: { value() { return ( i = 0 ) } },\nitem: { value(num) { return num != null ? this[ num ] : this[ i ] } }\n} )\n}\nmap( callback ) {\nvar T, A, k\nif ( this == null ) {\nthrow new TypeError( 'this is null or not defined' )\n}\nvar O = Object( this )\nvar len = O.length >>> 0\nif ( typeof callback !== 'function' ) {\nthrow new TypeError(callback + ' is not a function' )\n}\nif ( arguments.length > 1) {\nT = arguments[1]\n}\nA = new Array(len)\nk = 0\nwhile (k < len) {\nvar kValue, mappedValue\nif ( k in O ) {\nkValue = O[k]\nmappedValue = callback.call(T, kValue, k, O)\nA[k] = mappedValue\n}\nk++\n}\nreturn A\n}\nfilter( func, thisArg ) {\n'use strict'\nif (\n!(\n( typeof func === 'Function' || typeof func === 'function' ) &&\nthis\n)\n)\nthrow new TypeError()\nvar len = this.length >>> 0,\nres = new Array( len ),\nt = this,\nc = 0,\ni = -1\nif ( thisArg === undefined ) {\nwhile ( ++i !== len ) {\nif (i in this) {\nif ( func( t[ i ], i, t ) ) {\nres[ c++ ] = t[ i ]\n}\n}\n}\n} else {\nwhile ( ++i !== len ) {\nif ( i in this ) {\nif ( func.call( thisArg, t[ i ], i, t ) ) {\nres[ c++ ] = t[ i ]\n}\n}\n}\n}\nres.length = c\nreturn res\n}\n}\nEnumerator.Enumerator = Enumerators\nmodule.exports = Enumerator",
        "mapping": {},
        "name": null
    },
    "io": {
        "source": "const UTF8Encoding = require('System.Text.UTF8Encoding')\nconst ADODB = require('ADODB.Stream')\nconst DOMDocument = require('Msxml2.DOMDocument')\nconst SHIFT_JIS = 'Shift-JIS'\nconst UTF_8 = 'UTF-8'\nconst UTF_8BOM = 'UTF-8BOM'\nconst UTF_8N = 'UTF-8N'\nconst AD_TYPE_BINARY = 1\nconst AD_TYPE_TEXT = 2\nconst AD_SAVE_CREAE_OVER_WRITE = 2\nconst binary2UTF8 = ( binary ) => {\nreturn UTF8Encoding.GetString( binary )\n}\nconst binary2SJIS = ( binary ) => {\nlet source = ''\ntry {\nADODB.Open()\nADODB.Type = AD_TYPE_BINARY\nADODB.Write(binary)\nADODB.Position = 0\nADODB.Type = AD_TYPE_TEXT\nADODB.Charset = SHIFT_JIS\nsource = ADODB.ReadText()\n} catch (error) {\nconsole.log( `error binary2SJIS ${ error }` )\n} finally {\nADODB.Close()\n}\nreturn source\n}\nconst binary2Hex = ( binary ) => {\nlet hex = require('Msxml2.DOMDocument').createElement('hex')\nhex.dataType = 'bin.hex'\nhex.nodeTypedValue = binary\nreturn hex.text\n}\nconst Hex2binary = ( text ) => {\nlet hex = require('Msxml2.DOMDocument').createElement('hex')\nhex.dataType = 'bin.hex'\nhex.text = text\nreturn hex.nodeTypedValue\n}\nconst UTF82bynary = ( text ) => require( 'System.Text.UTF8Encoding' ).GetBytes_4( text )\nconst SJIS2binary = ( text ) => {\nconst stream = require( 'ADODB.Stream' )\nstream.Open()\nstream.Type = AD_TYPE_TEXT\nstream.Charset = SHIFT_JIS\nstream.WriteText( text )\nstream.Position = 0\nstream.Type = AD_TYPE_BINARY\nconst res = stream.Read()\nstream.Close()\nreturn res\n}\nconst ReadBinaryFile = ( path ) => {\nlet source = ''\ntry {\nADODB.Type = AD_TYPE_BINARY\nADODB.Open()\nADODB.LoadFromFile( path )\nsource = ADODB.Read()\n} catch ( error ) {\nconsole.log( `error ReadBinaryFile ${ error } ${ path }` )\n} finally {\nADODB.Close()\n}\nreturn source\n}\nconst autoGuessEncode = ( binary ) => {\nlet hex = binary2Hex( binary )\nif ( /^efbbbf.+/.test(hex) ) return UTF_8BOM\nlet hexes = []\nfor ( let i = 0; i < hex.length; i++ ) {\nhexes.push( Number( `0x${ hex[i] }${ hex[i + 1] }` ) )\ni++\n}\nlet len = hexes.length\nif ( len < 2 ) return UTF_8N\nlet sjis = 0\nlet utf8 = 0\nfor ( let i = 0; i < len - 2; i++ ) {\nconst hex1 = hexes[i]\nconst hex2 = hexes[i + 1]\nconst hex3 = hexes[i + 2]\nif (\n( ( 0x81 <= hex1 && hex1 <= 0x9f ) || ( 0xe0 <= hex1 && hex1 <= 0xfc ) ) &&\n( (0x40 <= hex2 && hex2 <= 0x7e ) || ( 0x80 <= hex2 && hex2 <= 0xfc ) )\n) sjis += 2\nif (0xc0 <= hex1 && hex1 <= 0xdf && (0x80 <= hex2 && hex2 <= 0xbf)) utf8 += 2\nelse if (\n0xe0 <= hex1 &&\nhex1 <= 0xef &&\n(0x80 <= hex2 && hex2 <= 0xbf) &&\n(0x80 <= hex3 && hex3 <= 0xbf)\n) {\nutf8 += 3\ni += 2\n}\ni++\n}\nreturn sjis > utf8 ? SHIFT_JIS : UTF_8N\n}\nconst read = ( filespec, enc ) => {\nlet binary = ReadBinaryFile( filespec )\nlet encode = enc || autoGuessEncode( binary )\nif (encode.toLowerCase() === SHIFT_JIS.toLowerCase()) return binary2SJIS( binary )\nif (encode.toLowerCase() === UTF_8BOM.toLowerCase() || encode.toLowerCase() === UTF_8.toLowerCase() ) {\nreturn binary2UTF8( Hex2binary( binary2Hex( binary ).replace(/^efbbbf/, '') ) )\n}\nreturn binary2UTF8(binary)\n}\nconst write = ( filespec, text, enc ) => {\nconst ADODB = require('ADODB.Stream')\ntry {\nADODB.Type = AD_TYPE_TEXT\nif ( enc == null ) ADODB.CharSet = enc = SHIFT_JIS\nelse if ( enc.toLowerCase() === UTF_8N.toLowerCase() ) ADODB.CharSet = UTF_8\nelse ADODB.CharSet = enc\nADODB.Open()\nADODB.WriteText( text )\nif ( enc.toLowerCase() === UTF_8N.toLowerCase() ) {\nADODB.Position = 0\nADODB.Type = AD_TYPE_BINARY\nADODB.Position = 3\nlet bytes = ADODB.Read()\nADODB.Position = 0\nADODB.SetEOS()\nADODB.Write( bytes )\n}\nADODB.SaveToFile( filespec, AD_SAVE_CREAE_OVER_WRITE )\n} catch ( error ) {\nreturn console.log( `failed to writing '${ filespec }'\\n${ error }`)\n} finally {\nADODB.Close()\n}\nreturn `succeeded in writing '${ filespec }'`\n}\nconst win32Sep = '\\\\'\nconst posixSep = '/'\nconst toWin32Sep = ( path ) => path.split( posixSep ).join( win32Sep )\nconst toPosixSep = ( path ) => path.split( win32Sep ).join( posixSep )\nconst absolute = ( path ) => toPosixSep( FSO.GetAbsolutePathName( toWin32Sep( path ) ) )\nconst split = ( path ) => toPosixSep( path ).split( posixSep )\nconst join = ( ...paths ) => absolute( toWin32Sep( paths.reduce( ( acc, curr ) => `${ acc }${ win32Sep }${ curr }` ) ) )\nconst dirname = ( path ) => absolute( FSO.GetParentFolderName( toWin32Sep( path ) ) )\nconst fileExists = ( path ) => FSO.FileExists( toWin32Sep( path ) )\nmodule.exports = {\nreadFileSync: read,\nwriteFileSync: write,\nautoGuessEncode,\nwin32Sep,\nposixSep,\ntoWin32Sep,\ntoPosixSep,\nabsolute,\nsplit,\njoin,\ndirname,\nfileExists,\nReadBinaryFile,\nbinary2UTF8,\nbinary2SJIS,\nbinary2Hex,\nHex2binary,\nUTF82bynary,\nSJIS2binary\n}\n",
        "mapping": {},
        "name": null
    },
    "log": {
        "source": "const log = ( code ) => {\nlet res = code()\nswitch ( true ) {\ncase typeof res === 'function' || res instanceof RegExp:\nres = res.toString()\nbreak\ncase res instanceof Date:\nres = res.toISOString()\nbreak\ncase res === ( function(){} )():\nres = 'undefined'\nbreak\ncase res === null:\nres = null\nbreak\ndefault:\nres = JSON.stringify( res, null, 2 )\n}\nconst { brightGreen: green } = console.ansi\nconsole.log( code.toString() + green + ' // => ' + res )\n}\nmodule.exports = log",
        "mapping": {},
        "name": null
    },
    "sc": {
        "source": "const ScriptControl = ( language ) => {\nconst sc = require( 'ScriptControl' )\nsc.Language = language\nreturn {\nAddCode( code ) {\nsc.AddCode( code )\n},\nRun( name, ...args ) {\nreturn sc.run( name, ...args )\n}\n}\n}\nmodule.exports = {\nJScript: ScriptControl( 'JScript' ),\nVBScript: ScriptControl( 'VBScript' )\n}\n",
        "mapping": {},
        "name": null
    },
    "test": {
        "source": "let depth = 0\nlet caption = []\nlet indent = \"\"\nlet rate = 4\nlet space = \" \"\nlet noop = ( () => {} )\nlet n = '\\n'\nconst checkMark = '\\u2714'\nconst {\nbrightRed: red,\nbrightGreen: green,\nbrightYellow: yellow,\nbrightMagenta: pink,\ngray\n} = console.ansi\nconst describe = ( title, fn ) => {\nlet s = depth ? '' : n\ndepth++\nindent = space.repeat( depth * rate )\nconsole.log( s + indent + title + n )\nfn()\ndepth--\n}\nconst it = ( message, fn ) => {\ndepth++\nindent = space.repeat( depth * rate )\nconst printCode = ( code ) => {\nlet source = code.toString().split( '\\t' ).join( '    ' ).split( /\\r?\\n/ )\nif ( source.length < 2 ) return `${ space.repeat( indent + rate ) }${ source[0] }`\nsource[0] = `${ source[ source.length - 1 ].match( /^\\s+/ )[0] }${ source[0] }`\nconst sp = source.map( v => v.match( /^\\s+/ )[0].length )\nconst min = Math.min.apply( null, sp )\nreturn source.map( ( v ) => {\nreturn `${ space.repeat( ( depth + 1 ) * rate ) }${ v.replace( space.repeat( min ), \"\"  ) }`\n} ).join( \"\\n\" )\n}\ntry {\nfn()\nconsole.log( `${ indent }${ gray }${ message } ${ green }${ checkMark }` )\n} catch ( e ) {\nconsole.log( `${ indent }${ pink }${ message }\\n${ yellow }${ printCode( fn ) } ${ red }// => ${ e.message }${ n }` )\n} finally {\ndepth--\n}\n}\nconst assert = ( assertion ) => {\nreturn assert.ok( assertion )\n}\nassert.ok = ( assertion ) => {\nlet res = typeof assertion === 'function' ? assertion() : assertion\nif ( !res ) throw new Error( res )\n}\nassert.ng = ( assertion ) => {\nlet res = typeof assertion === 'function' ? assertion() : assertion\nif ( res ) throw new Error( res )\n}\nmodule.exports = {\ndescribe,\nit,\nassert\n}\n",
        "mapping": {},
        "name": null
    },
    "vbs": {
        "source": "const { VBScript } = require( 'sc' )\nVBScript.AddCode(`\nFunction getTypeName( obj )\ngetTypeName = TypeName( obj )\nEnd Function\n`)\nVBScript.AddCode(`\nFunction getVarType( obj )\ngetVarType = VarType( obj )\nEnd Function\n`)\nconst TypeName = ( object ) => VBScript.Run( 'getTypeName', object )\nconst VarType = ( object ) => VBScript.Run( 'getVarType', object )\nconst Type = ( object ) => {\nconst constant = [\n'vbEmpty', // 0\n'vbNull', // 1\n'vbInteger', // 2\n'vbLong', // 3\n'vbSingle', // 4\n'vbDouble', // 5\n'vbCurrency', // 6\n'vbDate', // 7\n'vbString', // 8\n'vbObject', // 9\n'vbError', // 10\n'vbBoolean', // 11\n'vbVariant', // 12\n'vbDataObject', // 13\n]\nlet num = VarType( object )\nreturn  num > 8192 ? `${ constant[ num - 8192 ] }[]` : constant[ num ]\n}\nType[17] = 'vbByte'\nType[8192] = 'vbArray'\nmodule.exports = {\nTypeName,\nVarType,\nType\n}\n",
        "mapping": {},
        "name": null
    }
}