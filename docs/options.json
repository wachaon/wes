{
    "setting": {
        "# *WES*": {
            "content": "# *WES*\n\n*wes* は *WSH (Windows Script Host)* で *ECMAScript* を実行する、コンソール用のフレームワークです。\n*README* の原文は [*japanese*](/README.md) になります。日本語以外は機械翻訳の文章になります。\\\n他言語の文章は下記から選択してください。\n\n*import document*",
            "translated": {
                "en": "# *WES*\n\n*wes* is a console framework for running *ECMAScript* on *WSH (Windows Script Host)* . The original [*japanese*](/README.md) of the *README* will be in Japanese. Texts other than Japanese will be machine translated.\\\nFor texts in other languages, please select from the options below.\n\n*import document*\n",
                "zh-CN": "# *WES*\n\n*wes*是一个控制台框架，用于在*WSH (Windows Script Host)*上运行*ECMAScript* 。 *README*文件的[*japanese*](/README.md)将是日文。日语以外的文本将被机器翻译。\\\n对于其他语言的文本，请从以下选项中选择。\n\n*import document*\n",
                "zh-TW": "# *WES*\n\n*wes*是一個控制台框架，用於在*WSH (Windows Script Host)*上運行*ECMAScript* 。 *README*文件的[*japanese*](/README.md)將是日文。日語以外的文本將被機器翻譯。\\\n對於其他語言的文本，請從以下選項中進行選擇。\n\n*import document*\n",
                "es": "# *WES*\n\n*wes* es un marco de consola para ejecutar *ECMAScript* en *WSH (Windows Script Host)* . El [*japanese*](/README.md) original del *README* estará en japonés. Los textos que no sean en japonés serán traducidos automáticamente.\\\nPara textos en otros idiomas, seleccione entre las opciones a continuación.\n\n*import document*\n",
                "de": "# *WES*\n\n*wes* ist ein Konsolen-Framework zum Ausführen von *ECMAScript* auf *WSH (Windows Script Host)* . Der [*japanese*](/README.md) der *README* wird auf Japanisch sein. Andere Texte als Japanisch werden maschinell übersetzt.\\\nFür Texte in anderen Sprachen wählen Sie bitte aus den folgenden Optionen aus.\n\n*import document*\n",
                "fr": "# *WES*\n\n*wes* est un framework de console pour exécuter *ECMAScript* sur *WSH (Windows Script Host)* . Le [*japanese*](/README.md) original du *README* sera en japonais. Les textes autres que le japonais seront traduits automatiquement.\\\nPour les textes dans d'autres langues, veuillez sélectionner parmi les options ci-dessous.\n\n*import document*\n",
                "hi": "# *WES*\n\n*WSH (Windows Script Host)* पर *ECMAScript* चलाने के लिए *wes* एक कंसोल फ्रेमवर्क है। *README* का मूल [*japanese*](/README.md) जापानी में होगा। जापानी के अलावा अन्य ग्रंथों का मशीनी अनुवाद किया जाएगा।\\\nअन्य भाषाओं में पाठ के लिए, कृपया नीचे दिए गए विकल्पों में से चुनें।\n\n*import document*\n",
                "pt": "# *WES*\n\n*wes* é uma estrutura de console para executar o *ECMAScript* no *WSH (Windows Script Host)* . O [*japanese*](/README.md) original do *README* será em japonês. Textos diferentes do japonês serão traduzidos automaticamente.\\\nPara textos em outros idiomas, selecione uma das opções abaixo.\n\n*import document*\n",
                "it": "# *WES*\n\n*wes* è un framework console per l'esecuzione di *ECMAScript* su *WSH (Windows Script Host)* . Il [*japanese*](/README.md) originale del *README* sarà in giapponese. I testi diversi dal giapponese verranno tradotti automaticamente.\\\nPer testi in altre lingue, seleziona una delle opzioni seguenti.\n\n*import document*\n",
                "ru": "# *WES*\n\n*wes* — консольный фреймворк для запуска *ECMAScript* на *WSH (Windows Script Host)* . Оригинальный [*japanese*](/README.md) *README* будет на японском языке. Тексты, отличные от японского, будут переведены автоматически.\\\nДля текстов на других языках выберите один из вариантов ниже.\n\n*import document*\n",
                "ms": "# *WES*\n\n*wes* ialah rangka kerja konsol untuk menjalankan *ECMAScript* pada *WSH (Windows Script Host)* . [*japanese*](/README.md) asal *README* adalah dalam bahasa Jepun. Teks selain bahasa Jepun akan diterjemahkan mesin.\\\nUntuk teks dalam bahasa lain, sila pilih daripada pilihan di bawah.\n\n*import document*\n",
                "nl": "# *WES*\n\n*wes* is een consoleframework voor het uitvoeren van *ECMAScript* op *WSH (Windows Script Host)* . De originele [*japanese*](/README.md) van de *README* zal in het Japans zijn. Andere teksten dan het Japans worden machinaal vertaald.\\\nVoor teksten in andere talen kunt u een keuze maken uit de onderstaande opties.\n\n*import document*\n",
                "ar": "# *WES*\n\n*wes* هو إطار عمل لوحدة التحكم لتشغيل *ECMAScript* على *WSH (Windows Script Host)* . سيكون [*japanese*](/README.md) الأصلي من *README* باللغة اليابانية. سيتم ترجمة النصوص غير اليابانية آليًا.\\\nللنصوص بلغات أخرى ، يرجى التحديد من الخيارات أدناه.\n\n*import document*\n",
                "bn": "# *WES*\n\n*wes* হল *WSH (Windows Script Host)* এ *ECMAScript* চালানোর জন্য একটি কনসোল ফ্রেমওয়ার্ক। *README* এর মূল [*japanese*](/README.md) জাপানি ভাষায় হবে। জাপানি ব্যতীত অন্য পাঠ্যগুলি মেশিন অনুবাদ করা হবে।\\\nঅন্যান্য ভাষার পাঠ্যের জন্য, অনুগ্রহ করে নীচের বিকল্পগুলি থেকে নির্বাচন করুন৷\n\n*import document*\n"
            }
        },
        "# 特徴": {
            "content": "# 特徴\n\n*   スクリプトエンジンを *Chakra* に変更して *ECMAScript2015+* の仕様で記述できます\n*   常に 32bit の *cscript.exe* を実行するので、64bit 環境での固有の不具合が起こりません\n*   モジュールシステムがあるので従来の *WSH* より効率的に開発できます\n*   ビルトインモジュールがファイルの入出力やコンソールへ色付き文字を出力などの基本的な処理をサポートします\n*   ファイルの読み込みにエンコードを自動推測させることができるので、エンコードなどを気にする必要がありません\n*   モジュールをパッケージ化して外部公開や取得もサポートします",
            "translated": {
                "en": "# feature\n\n*   You can change the script engine to *Chakra* and write according to *ECMAScript2015* specifications.\n*   Since 32bit *cscript.exe* is always executed, there is no unique problem in 64bit environment.\n*   Since there is a module system, it can be developed more efficiently than the conventional *WSH*\n*   Built-in modules support basic processing such as file input/output and colored text output to the console\n*   You can let file reading automatically guess the encoding, so you don't have to worry about encoding etc.\n*   Package modules to support external publishing and retrieval\n",
                "zh-CN": "# 特征\n\n*   您可以将脚本引擎更改为*Chakra*并根据*ECMAScript2015*规范编写。\n*   由于始终执行 32 位*cscript.exe* ，因此在 64 位环境中没有唯一问题。\n*   由于有一个模块系统，它可以比传统的*WSH*更有效地开发\n*   内置模块支持基本处理，例如文件输入/输出和彩色文本输出到控制台\n*   您可以让文件读取自动猜测编码，因此您不必担心编码等。\n*   打包模块以支持外部发布和检索\n",
                "zh-TW": "# 特徵\n\n*   您可以將腳本引擎更改為*Chakra*並根據*ECMAScript2015*規範編寫。\n*   由於總是執行 32 位*cscript.exe* ，因此在 64 位環境中沒有獨特的問題。\n*   由於有模塊系統，因此可以比傳統的*WSH*更高效地開發\n*   內置模塊支持基本處理，例如文件輸入/輸出和彩色文本輸出到控制台\n*   您可以讓文件讀取自動猜測編碼，因此您不必擔心編碼等。\n*   打包模塊以支持外部發布和檢索\n",
                "es": "# rasgo\n\n*   Puede cambiar el motor de secuencias de comandos a *Chakra* y escribir de acuerdo con las especificaciones de *ECMAScript2015* .\n*   Dado que *cscript.exe* de 32 bits siempre se ejecuta, no hay un problema único en el entorno de 64 bits.\n*   Dado que hay un sistema de módulos, se puede desarrollar de manera más eficiente que el *WSH* convencional\n*   Los módulos incorporados admiten el procesamiento básico, como la entrada/salida de archivos y la salida de texto en color a la consola\n*   Puede dejar que la lectura de archivos adivine automáticamente la codificación, para que no tenga que preocuparse por la codificación, etc.\n*   Paquete de módulos para admitir la publicación y recuperación externas\n",
                "de": "# Besonderheit\n\n*   Sie können die Skript-Engine auf *Chakra* ändern und gemäß den *ECMAScript2015* -Spezifikationen schreiben.\n*   Da 32-Bit *cscript.exe* immer ausgeführt wird, gibt es in der 64-Bit-Umgebung kein eindeutiges Problem.\n*   Da es sich um ein Modulsystem handelt, kann es effizienter entwickelt werden als das herkömmliche *WSH*\n*   Eingebaute Module unterstützen die grundlegende Verarbeitung wie Dateieingabe/-ausgabe und Farbtextausgabe an die Konsole\n*   Sie können die Codierung beim Lesen von Dateien automatisch erraten lassen, sodass Sie sich keine Gedanken über die Codierung usw. machen müssen.\n*   Paketmodule zur Unterstützung externer Veröffentlichungen und Abrufe\n",
                "fr": "# caractéristique\n\n*   Vous pouvez changer le moteur de script en *Chakra* et écrire selon les spécifications *ECMAScript2015* .\n*   Étant donné que *cscript.exe* 32 bits est toujours exécuté, il n'y a pas de problème unique dans un environnement 64 bits.\n*   Puisqu'il existe un système de modules, il peut être développé plus efficacement que le *WSH* conventionnel\n*   Les modules intégrés prennent en charge le traitement de base tel que l'entrée/sortie de fichiers et la sortie de texte coloré vers la console\n*   Vous pouvez laisser la lecture du fichier deviner automatiquement l'encodage, vous n'avez donc pas à vous soucier de l'encodage, etc.\n*   Modules de package pour prendre en charge la publication et la récupération externes\n",
                "hi": "# विशेषता\n\n*   आप स्क्रिप्ट इंजन को *Chakra* में बदल सकते हैं और *ECMAScript2015* विनिर्देशों के अनुसार लिख सकते हैं।\n*   चूंकि 32 बिट *cscript.exe* हमेशा निष्पादित होता है, 64 बिट वातावरण में कोई अनूठी समस्या नहीं है।\n*   चूंकि एक मॉड्यूल प्रणाली है, इसे पारंपरिक *WSH* की तुलना में अधिक कुशलता से विकसित किया जा सकता है\n*   बिल्ट-इन मॉड्यूल कंसोल में फ़ाइल इनपुट/आउटपुट और रंगीन टेक्स्ट आउटपुट जैसे बुनियादी प्रसंस्करण का समर्थन करते हैं\n*   आप फ़ाइल रीडिंग को स्वचालित रूप से एन्कोडिंग का अनुमान लगाने दे सकते हैं, इसलिए आपको एन्कोडिंग आदि के बारे में चिंता करने की ज़रूरत नहीं है।\n*   बाहरी प्रकाशन और पुनर्प्राप्ति का समर्थन करने के लिए पैकेज मॉड्यूल\n",
                "pt": "# característica\n\n*   Você pode alterar o mecanismo de script para *Chakra* e escrever de acordo com as especificações *ECMAScript2015* .\n*   Como o *cscript.exe* de 32 bits é sempre executado, não há nenhum problema exclusivo no ambiente de 64 bits.\n*   Como existe um sistema de módulos, ele pode ser desenvolvido de forma mais eficiente que o *WSH* convencional\n*   Módulos integrados suportam processamento básico, como entrada/saída de arquivo e saída de texto colorido para o console\n*   Você pode deixar a leitura do arquivo adivinhar automaticamente a codificação, para que você não precise se preocupar com a codificação, etc.\n*   Módulos de pacote para dar suporte à publicação e recuperação externas\n",
                "it": "# caratteristica\n\n*   Puoi cambiare il motore di script in *Chakra* e scrivere secondo le specifiche *ECMAScript2015* .\n*   Poiché *cscript.exe* a 32 bit viene sempre eseguito, non ci sono problemi univoci nell'ambiente a 64 bit.\n*   Poiché esiste un sistema di moduli, può essere sviluppato in modo più efficiente rispetto al *WSH* convenzionale\n*   I moduli integrati supportano l'elaborazione di base come input/output di file e output di testo colorato sulla console\n*   Puoi lasciare che la lettura del file indovini automaticamente la codifica, quindi non devi preoccuparti della codifica ecc.\n*   Moduli del pacchetto per supportare la pubblicazione e il recupero esterni\n",
                "ru": "# особенность\n\n*   Вы можете изменить скриптовый движок на *Chakra* и писать в соответствии со спецификациями *ECMAScript2015* .\n*   Поскольку 32 *cscript.exe* всегда выполняется, в 64-битной среде нет уникальной проблемы.\n*   Поскольку существует модульная система, ее можно развивать более эффективно, чем обычную *WSH* .\n*   Встроенные модули поддерживают базовую обработку, такую ​​как ввод/вывод файлов и вывод цветного текста на консоль.\n*   Вы можете позволить чтению файла автоматически угадывать кодировку, поэтому вам не нужно беспокоиться о кодировке и т. д.\n*   Пакетные модули для поддержки внешней публикации и поиска\n",
                "ms": "# ciri\n\n*   Anda boleh menukar enjin skrip kepada *Chakra* dan menulis mengikut spesifikasi *ECMAScript2015* .\n*   Memandangkan 32bit *cscript.exe* sentiasa dilaksanakan, tiada masalah unik dalam persekitaran 64bit.\n*   Memandangkan terdapat sistem modul, ia boleh dibangunkan dengan lebih cekap daripada *WSH* konvensional\n*   Modul terbina dalam menyokong pemprosesan asas seperti input/output fail dan output teks berwarna ke konsol\n*   Anda boleh membiarkan pembacaan fail meneka pengekodan secara automatik, jadi anda tidak perlu risau tentang pengekodan dsb.\n*   Pakej modul untuk menyokong penerbitan dan pengambilan luaran\n",
                "nl": "# voorzien zijn van\n\n*   U kunt de scriptengine wijzigen in *Chakra* en schrijven volgens *ECMAScript2015* -specificaties.\n*   Aangezien 32bit *cscript.exe* altijd wordt uitgevoerd, is er geen uniek probleem in een 64bit-omgeving.\n*   Omdat er een modulesysteem is, kan het efficiënter worden ontwikkeld dan de conventionele *WSH*\n*   Ingebouwde modules ondersteunen basisverwerking zoals invoer/uitvoer van bestanden en uitvoer van gekleurde tekst naar de console\n*   U kunt het lezen van bestanden automatisch de codering laten raden, zodat u zich geen zorgen hoeft te maken over codering enz.\n*   Pakketmodules ter ondersteuning van extern publiceren en ophalen\n",
                "ar": "# خاصية\n\n*   يمكنك تغيير محرك البرنامج النصي إلى *Chakra* والكتابة وفقًا لمواصفات *ECMAScript2015* .\n*   نظرًا لأنه يتم دائمًا تنفيذ 32bit *cscript.exe* ، فلا توجد مشكلة فريدة في بيئة 64 بت.\n*   نظرًا لوجود نظام وحدة نمطية ، يمكن تطويره بشكل أكثر كفاءة من *WSH* التقليدي\n*   تدعم الوحدات المدمجة المعالجة الأساسية مثل إدخال / إخراج الملف وإخراج النص الملون إلى وحدة التحكم\n*   يمكنك السماح لقراءة الملف تلقائيًا بتخمين الترميز ، لذلك لا داعي للقلق بشأن الترميز وما إلى ذلك.\n*   وحدات الحزمة لدعم النشر الخارجي والاسترجاع\n",
                "bn": "# বৈশিষ্ট্য\n\n*   আপনি স্ক্রিপ্ট ইঞ্জিনকে *Chakra* পরিবর্তন করতে পারেন এবং *ECMAScript2015* স্পেসিফিকেশন অনুযায়ী লিখতে পারেন।\n*   যেহেতু 32bit *cscript.exe* সর্বদা কার্যকর করা হয়, তাই 64bit পরিবেশে কোন অনন্য সমস্যা নেই।\n*   যেহেতু একটি মডিউল সিস্টেম রয়েছে, এটি প্রচলিত *WSH* এর চেয়ে আরও দক্ষতার সাথে বিকাশ করা যেতে পারে\n*   অন্তর্নির্মিত মডিউলগুলি মৌলিক প্রক্রিয়াকরণকে সমর্থন করে যেমন ফাইল ইনপুট/আউটপুট এবং কনসোলে রঙিন পাঠ্য আউটপুট\n*   আপনি ফাইল রিডিং স্বয়ংক্রিয়ভাবে এনকোডিং অনুমান করতে দিতে পারেন, তাই আপনাকে এনকোডিং ইত্যাদি সম্পর্কে চিন্তা করতে হবে না।\n*   বাহ্যিক প্রকাশনা এবং পুনরুদ্ধার সমর্থন করার জন্য প্যাকেজ মডিউল\n"
            }
        },
        "# *wes* が解決できない既知の問題": {
            "content": "# *wes* が解決できない既知の問題\n\n*   `WScript.Quit` はプログラムを中断出来ず、エラーコードも返しません\n*   非同期処理は正しく機能しません\n*   `WScript.CreateObject` の第二引数の *event prefix* の使用はできません",
            "translated": {
                "en": "# *wes* issues that we can't solve\n\n*   `WScript.Quit` cannot abort the program and does not return an error code\n*   Asynchronous processing does not work properly\n*   You cannot use the *event prefix* of the second argument of `WScript.CreateObject`\n",
                "zh-CN": "# 我们无法解决的*wes*问题\n\n*   `WScript.Quit`不能中止程序并且不返回错误代码\n*   异步处理无法正常工作\n*   您不能使用`WScript.CreateObject`的第二个参数的*event prefix*\n",
                "zh-TW": "# 我們無法解決的*wes*問題\n\n*   `WScript.Quit`不能中止程序並且不返回錯誤代碼\n*   異步處理無法正常工作\n*   您不能使用`WScript.CreateObject`的第二個參數的*event prefix*\n",
                "es": "# Problemas *wes* que no podemos resolver\n\n*   `WScript.Quit` no puede cancelar el programa y no devuelve un código de error\n*   El procesamiento asíncrono no funciona correctamente\n*   No puede usar el *event prefix* del segundo argumento de `WScript.CreateObject`\n",
                "de": "# *wes* Probleme, die wir nicht lösen können\n\n*   `WScript.Quit` kann das Programm nicht abbrechen und gibt keinen Fehlercode zurück\n*   Die asynchrone Verarbeitung funktioniert nicht richtig\n*   Sie können das *event prefix* des zweiten Arguments von `WScript.CreateObject` nicht verwenden\n",
                "fr": "# Problèmes *wes* que nous ne pouvons pas résoudre\n\n*   `WScript.Quit` ne peut pas interrompre le programme et ne renvoie pas de code d'erreur\n*   Le traitement asynchrone ne fonctionne pas correctement\n*   Vous ne pouvez pas utiliser le *event prefix* du deuxième argument de `WScript.CreateObject`\n",
                "hi": "# *wes* मुद्दे जिन्हें हम हल नहीं कर सकते\n\n*   `WScript.Quit` प्रोग्राम को निरस्त नहीं कर सकता और त्रुटि कोड नहीं लौटाता\n*   अतुल्यकालिक प्रसंस्करण ठीक से काम नहीं करता है\n*   आप WScript के दूसरे तर्क के *event prefix* का उपयोग नहीं कर सकते हैं। `WScript.CreateObject`\n",
                "pt": "# *wes* que não podemos resolver\n\n*   `WScript.Quit` não pode abortar o programa e não retorna um código de erro\n*   O processamento assíncrono não funciona corretamente\n*   Você não pode usar o *event prefix* do segundo argumento de `WScript.CreateObject`\n",
                "it": "# Problemi *wes* che non possiamo risolvere\n\n*   `WScript.Quit` non può interrompere il programma e non restituisce un codice di errore\n*   L'elaborazione asincrona non funziona correttamente\n*   Non è possibile utilizzare il *event prefix* del secondo argomento di `WScript.CreateObject`\n",
                "ru": "# *wes* проблемы, которые мы не можем решить\n\n*   `WScript.Quit` не может прервать программу и не возвращает код ошибки.\n*   Асинхронная обработка работает неправильно\n*   Вы не можете использовать *event prefix* второго аргумента `WScript.CreateObject`\n",
                "ms": "# Isu yang *wes* yang tidak dapat kami selesaikan\n\n*   `WScript.Quit` tidak boleh membatalkan program dan tidak mengembalikan kod ralat\n*   Pemprosesan tak segerak tidak berfungsi dengan betul\n*   Anda tidak boleh menggunakan *event prefix* bagi argumen kedua `WScript.CreateObject`\n",
                "nl": "# *wes* problemen die we niet kunnen oplossen\n\n*   `WScript.Quit` kan het programma niet afbreken en geeft geen foutcode terug\n*   Asynchrone verwerking werkt niet goed\n*   U kunt het *event prefix* van het tweede argument van `WScript.CreateObject` . niet gebruiken\n",
                "ar": "# المشكلات *wes* التي لا يمكننا حلها\n\n*   لا يمكن لـ `WScript.Quit` إحباط البرنامج ولا يُرجع رمز خطأ\n*   المعالجة غير المتزامنة لا تعمل بشكل صحيح\n*   لا يمكنك استخدام *event prefix* للوسيطة الثانية من `WScript.CreateObject`\n",
                "bn": "# *wes* সমস্যা যা আমরা সমাধান করতে পারি না\n\n*   `WScript.Quit` প্রোগ্রামটি বাতিল করতে পারে না এবং একটি ত্রুটি কোড ফেরত দেয় না\n*   অ্যাসিঙ্ক্রোনাস প্রক্রিয়াকরণ সঠিকভাবে কাজ করে না\n*   আপনি `WScript.CreateObject` এর দ্বিতীয় আর্গুমেন্টের *event prefix* ব্যবহার করতে পারবেন না\n"
            }
        },
        "# ダウンロード": {
            "content": "# ダウンロード\n\n*wes* に必要なのは *wes.js* ファイルのみです。\nダウンロードするには [*@wachaon/wes*](https://github.com/wachaon/wes) から *wes.js* をコピーするかコンソールで次のコマンドを実行してください。\n\n```bat\nbitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n```\n\n*wes* は実装として実行時に *WScript.Shell* の `SendKeys` を使用します。\n*wes.js* を保存するディレクトリのパスに *ascii* 以外文字が含まれていると `SendKeys` で正しくキーが送れず、\nスクリプトが実行できません。\\\n*wes.js* の保存先のパスは *ascii* のみで構成してください。\n既に *wes* をダウンロード済みの場合は次のコマンドでアップデートできます。\n\n```bat\nwes update\n```",
            "translated": {
                "en": "# download\n\n*wes.js* *wes* . To download, copy *wes.js* from [*@wachaon/wes*](https://github.com/wachaon/wes) or run the following command in console.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n*WScript.Shell* *wes* `SendKeys` at runtime as an implementation. If the path of the directory where *wes.js* is saved contains characters other than *ascii* , `SendKeys` cannot send the key correctly and the script cannot be executed.\\\nConfigure the path *wes.js* is stored in *ascii* only. If you have already downloaded *wes* , you can update it with the following command.\n\n     wes update\n",
                "zh-CN": "# 下载\n\n*wes.js* *wes* 。要下载，请从[*@wachaon/wes*](https://github.com/wachaon/wes)复制*wes.js*或在控制台中运行以下命令。\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n我们在运行时*WScript.Shell* *wes* `SendKeys`作为实现。如果*wes.js*保存目录的路径中包含*ascii*以外的字符，则`SendKeys`无法正确发送密钥，脚本无法执行。\\\n配置*wes.js*仅存储在*ascii*中的路径。如果您已经下载了*wes* ，您可以使用以下命令对其进行更新。\n\n     wes update\n",
                "zh-TW": "# 下載\n\n*wes.js* *wes* 。要下載，請從[*@wachaon/wes*](https://github.com/wachaon/wes)複製*wes.js*或在控制台中運行以下命令。\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n我們在運行時*WScript.Shell* *wes* `SendKeys`作為實現。如果*wes.js*保存目錄的路徑中包含*ascii*以外的字符，則`SendKeys`無法正確發送密鑰，腳本無法執行。\\\n配置*wes.js*僅存儲在*ascii*中的路徑。如果您已經下載了*wes* ，您可以使用以下命令對其進行更新。\n\n     wes update\n",
                "es": "# descargar\n\nWes solo necesita el *wes* *wes.js* Para descargar, copie *wes.js* desde [*@wachaon/wes*](https://github.com/wachaon/wes) o ejecute el siguiente comando en la consola.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\nUsamos `SendKeys` *wes* *WScript.Shell* en tiempo de ejecución como una implementación. Si la ruta del directorio donde se guarda *wes.js* contiene caracteres que no sean *ascii* , `SendKeys` no puede enviar la clave correctamente y el script no se puede ejecutar.\\\nConfigure la ruta *wes.js* solo en *ascii* . Si ya ha descargado *wes* , puede actualizarlo con el siguiente comando.\n\n     wes update\n",
                "de": "# Download\n\nWes benötigt nur die *wes* *wes.js* . Kopieren Sie zum Herunterladen *wes.js* von [*@wachaon/wes*](https://github.com/wachaon/wes) oder führen Sie den folgenden Befehl in der Konsole aus.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n`SendKeys` *WScript.Shell* *wes* zur Laufzeit als Implementierung. Wenn der Pfad des Verzeichnisses, in dem *wes.js* gespeichert ist, andere Zeichen als *ascii* enthält, kann `SendKeys` den Schlüssel nicht korrekt senden und das Skript kann nicht ausgeführt werden.\\\nKonfigurieren Sie den Pfad, *wes.js* gespeichert ist, nur in *ascii* . Wenn Sie *wes* bereits heruntergeladen haben, können Sie es mit dem folgenden Befehl aktualisieren.\n\n     wes update\n",
                "fr": "# Télécharger\n\nWes n'a besoin que du *wes* *wes.js* . Pour télécharger, copiez *wes.js* depuis [*@wachaon/wes*](https://github.com/wachaon/wes) ou exécutez la commande suivante dans la console.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\nNous utilisons `SendKeys` *wes* *WScript.Shell* lors de l'exécution en tant qu'implémentation. Si le chemin du répertoire où *wes.js* est enregistré contient des caractères autres que *ascii* , `SendKeys` ne peut pas envoyer la clé correctement et le script ne peut pas être exécuté.\\\nConfigurez le chemin *wes.js* est stocké en *ascii* uniquement. Si vous avez déjà téléchargé *wes* , vous pouvez le mettre à jour avec la commande suivante.\n\n     wes update\n",
                "hi": "# डाउनलोड\n\n*wes.js* *wes* की आवश्यकता है। डाउनलोड करने के लिए, *wes.js* को [*@wachaon/wes*](https://github.com/wachaon/wes) से कॉपी करें या कंसोल में निम्न कमांड चलाएँ।\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n*WScript.Shell* *wes* `SendKeys` का उपयोग करते हैं। यदि निर्देशिका का पथ जहां *wes.js* सहेजा गया है, उसमें *ascii* के अलावा अन्य वर्ण हैं, तो `SendKeys` कुंजी को सही ढंग से नहीं भेज सकता है और स्क्रिप्ट को निष्पादित नहीं किया जा सकता है।\\\nउस पथ को कॉन्फ़िगर करें *wes.js* केवल *ascii* में संग्रहीत है। यदि आपने पहले ही *wes* डाउनलोड कर लिया है, तो आप इसे निम्न कमांड से अपडेट कर सकते हैं।\n\n     wes update\n",
                "pt": "# download\n\nWes só precisa do *wes* *wes.js* Para baixar, copie *wes.js* de [*@wachaon/wes*](https://github.com/wachaon/wes) ou execute o seguinte comando no console.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\nNós usamos `SendKeys` *wes* *WScript.Shell* em tempo de execução como uma implementação. Se o caminho do diretório em que *wes.js* foi salvo contiver caracteres diferentes de *ascii* , `SendKeys` não poderá enviar a chave corretamente e o script não poderá ser executado.\\\nConfigure o caminho *wes.js* é armazenado apenas em *ascii* . Se você já baixou *wes* , pode atualizá-lo com o seguinte comando.\n\n     wes update\n",
                "it": "# Scarica\n\nWes ha bisogno solo del *wes* *wes.js* Per scaricare, copia *wes.js* da [*@wachaon/wes*](https://github.com/wachaon/wes) o esegui il seguente comando nella console.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\nUsiamo `SendKeys` *wes* *WScript.Shell* in fase di esecuzione come implementazione. Se il percorso della directory in cui è salvato *wes.js* contiene caratteri diversi da *ascii* , `SendKeys` non può inviare la chiave correttamente e lo script non può essere eseguito.\\\nConfigura il percorso *wes.js* è archiviato solo in *ascii* . Se hai già scaricato *wes* , puoi aggiornarlo con il seguente comando.\n\n     wes update\n",
                "ru": "# скачать\n\nУэсу нужен только *wes* *wes.js* Чтобы скачать, скопируйте *wes.js* из [*@wachaon/wes*](https://github.com/wachaon/wes) или выполните следующую команду в консоли.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n*WScript.Shell* `SendKeys` *wes* выполнения в качестве реализации. Если путь к каталогу, в котором сохранен *wes.js* , содержит символы, отличные от *ascii* , `SendKeys` не может правильно отправить ключ и скрипт не может быть выполнен.\\\nНастройте путь, по *wes.js* хранится только в формате *ascii* . Если вы уже загрузили *wes* , вы можете обновить его с помощью следующей команды.\n\n     wes update\n",
                "ms": "# muat turun\n\nWes hanya memerlukan *wes* *wes.js* . Untuk memuat turun, salin *wes.js* daripada [*@wachaon/wes*](https://github.com/wachaon/wes) atau jalankan arahan berikut dalam konsol.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n*WScript.Shell* *wes* pada masa `SendKeys` sebagai pelaksanaan. Jika laluan direktori tempat *wes.js* disimpan mengandungi aksara selain *ascii* , `SendKeys` tidak boleh menghantar kunci dengan betul dan skrip tidak boleh dilaksanakan.\\\nKonfigurasikan laluan *wes.js* disimpan dalam *ascii* sahaja. Jika anda telah memuat turun *wes* , anda boleh mengemas kininya dengan arahan berikut.\n\n     wes update\n",
                "nl": "# downloaden\n\nWes heeft alleen het *wes* *wes.js* . Om te downloaden, kopieert u *wes.js* van [*@wachaon/wes*](https://github.com/wachaon/wes) of voert u de volgende opdracht uit in de console.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n*WScript.Shell* *wes* `SendKeys` tijdens runtime als implementatie. Als het pad van de map waarin *wes.js* is opgeslagen andere tekens dan *ascii* bevat, kan `SendKeys` de sleutel niet correct verzenden en kan het script niet worden uitgevoerd.\\\nConfigureer het pad *wes.js* alleen in *ascii* wordt opgeslagen. Als je *wes* al hebt gedownload, kun je het bijwerken met de volgende opdracht.\n\n     wes update\n",
                "ar": "# تحميل\n\nيحتاج Wes إلى *wes* *wes.js* . للتنزيل ، انسخ *wes.js* من [*@wachaon/wes*](https://github.com/wachaon/wes) أو قم بتشغيل الأمر التالي في وحدة التحكم.\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n*WScript.Shell* `SendKeys` *wes* WScript.Shell في وقت التشغيل كتطبيق. إذا كان مسار الدليل الذي تم حفظ *wes.js* فيه يحتوي على أحرف غير *ascii* ، فلن يتمكن `SendKeys` من إرسال المفتاح بشكل صحيح ولا يمكن تنفيذ البرنامج النصي.\\\nقم بتكوين المسار *wes.js* في ملف *ascii* فقط. إذا قمت بالفعل بتنزيل *wes* ، فيمكنك تحديثه باستخدام الأمر التالي.\n\n     wes update\n",
                "bn": "# ডাউনলোড\n\n*wes.js* *wes* প্রয়োজন. ডাউনলোড করতে, [*@wachaon/wes*](https://github.com/wachaon/wes) থেকে *wes.js* কপি করুন বা কনসোলে নিম্নলিখিত কমান্ডটি চালান।\n\n     bitsadmin /TRANSFER GetWES https://raw.githubusercontent.com/wachaon/wes/master/wes.js %CD%\\\\wes.js\n\n*WScript.Shell* একটি বাস্তবায়ন হিসাবে রানটাইমে `SendKeys` *wes* SendKeys ব্যবহার করে। যদি ডিরেক্টরির পাথ যেখানে *wes.js* সংরক্ষিত হয় সেখানে *ascii* ছাড়া অন্য অক্ষর থাকে, `SendKeys` সঠিকভাবে কী পাঠাতে পারে না এবং স্ক্রিপ্টটি চালানো যাবে না।\\\nপাথ কনফিগার করুন *wes.js* শুধুমাত্র *ascii* তে সংরক্ষণ করা হয়। আপনি যদি ইতিমধ্যে *wes* ডাউনলোড করে থাকেন তবে আপনি নিম্নলিখিত কমান্ডের মাধ্যমে এটি আপডেট করতে পারেন।\n\n     wes update\n"
            }
        },
        "# 使い方": {
            "content": "# 使い方\n\n`wes` のキーワードに続きプログラムの起点となるファイルを指定したコマンドをコンソールへ入力します。\nスクリプトの拡張子 *.js* は省略できます。\n\n```bat\nwes index\n```\n\nまた、*wes* には *REP* が備わっているので、`wes` のみで起動させると、\nスクリプトを直接入力できます。\n\n```bat\nwes\n```\n\n*REP* は空行を２つ入力するまでスクリプトの入力を受け付けます。*README.md* でのサンプルスクリプトの\n実行も *REP* で確認できます。",
            "translated": {
                "en": "# Usage\n\nEnter the `wes` keyword followed by the command specifying the file that will be the starting point of the program to the console. The script extension *.js* can be omitted.\n\n     wes index\n\nAlso, since *wes* is equipped with *REP* , you can enter scripts directly by starting `wes` alone.\n\n     wes\n\n*REP* accepts script input until you enter two blank lines. You can also see *REP* running the example script in *README.md* .\n",
                "zh-CN": "# 用法\n\n输入`wes`关键字和指定将成为控制台程序起点的文件的命令。脚本扩展名*.js*可以省略。\n\n     wes index\n\n此外，由于*wes*配备了*REP* ，因此您可以通过单独启动`wes`直接输入脚本。\n\n     wes\n\n*REP*接受脚本输入，直到您输入两个空行。您还可以在*README.md*中看到*REP*运行示例脚本。\n",
                "zh-TW": "# 用法\n\n輸入`wes`關鍵字和指定將成為控制台程序起點的文件的命令。腳本擴展名*.js*可以省略。\n\n     wes index\n\n此外，由於*wes*配備了*REP* ，您可以通過單獨啟動`wes`直接輸入腳本。\n\n     wes\n\n*REP*接受腳本輸入，直到您輸入兩個空行。您還可以在*README.md*中看到*REP*運行示例腳本。\n",
                "es": "# Uso\n\nIngrese la palabra clave `wes` seguida del comando que especifica el archivo que será el punto de partida del programa en la consola. La extensión de secuencia de comandos *.js* se puede omitir.\n\n     wes index\n\nAdemás, dado que *wes* está equipado con *REP* , puede ingresar scripts directamente iniciando `wes` solo.\n\n     wes\n\n*REP* acepta entrada de script hasta que ingrese dos líneas en blanco. También puede ver a *REP* ejecutando el script de ejemplo en *README.md* .\n",
                "de": "# Verwendungszweck\n\nGeben Sie das Schlüsselwort `wes` gefolgt von dem Befehl ein, der die Datei angibt, die der Startpunkt des Programms für die Konsole sein wird. Die *.js* kann weggelassen werden.\n\n     wes index\n\nDa *wes* mit *REP* ausgestattet ist, können Sie Skripte auch direkt eingeben, indem Sie `wes` alleine starten.\n\n     wes\n\n*REP* akzeptiert Skripteingaben, bis Sie zwei Leerzeilen eingeben. Sie können auch sehen, wie *REP* das Beispielskript in *README.md* .\n",
                "fr": "# Usage\n\nEntrez le mot-clé `wes` suivi de la commande spécifiant le fichier qui sera le point de départ du programme vers la console. L'extension de script *.js* peut être omise.\n\n     wes index\n\nDe plus, étant donné que *wes* est équipé de *REP* , vous pouvez entrer des scripts directement en démarrant `wes` seul.\n\n     wes\n\n*REP* accepte l'entrée de script jusqu'à ce que vous saisissiez deux lignes vides. Vous pouvez également voir *REP* exécuter l'exemple de script dans *README.md* .\n",
                "hi": "# प्रयोग\n\nफ़ाइल को निर्दिष्ट करने वाले कमांड के बाद `wes` कीवर्ड दर्ज करें जो कंसोल के लिए प्रोग्राम का शुरुआती बिंदु होगा। स्क्रिप्ट एक्सटेंशन *.js* को छोड़ा जा सकता है।\n\n     wes index\n\nसाथ ही, चूंकि *wes* *REP* से लैस है, आप अकेले `wes` शुरू करके सीधे स्क्रिप्ट दर्ज कर सकते हैं।\n\n     wes\n\nजब तक आप दो रिक्त पंक्तियाँ दर्ज नहीं करते तब तक *REP* स्क्रिप्ट इनपुट स्वीकार करता है। आप *REP* को *README.md* में उदाहरण स्क्रिप्ट चलाते हुए भी देख सकते हैं।\n",
                "pt": "# Uso\n\nDigite a palavra-chave `wes` seguida do comando especificando o arquivo que será o ponto de partida do programa para o console. A extensão de script *.js* pode ser omitida.\n\n     wes index\n\nAlém disso, como *wes* está equipado com *REP* , você pode inserir scripts diretamente iniciando apenas `wes` .\n\n     wes\n\n*REP* aceita entrada de script até que você insira duas linhas em branco. Você também pode ver *REP* executando o script de exemplo em *README.md* .\n",
                "it": "# Utilizzo\n\nImmettere la parola chiave `wes` e il comando specificando il file che sarà il punto di partenza del programma nella console. L'estensione dello script *.js* può essere omessa.\n\n     wes index\n\nInoltre, poiché *wes* è dotato di *REP* , puoi inserire gli script direttamente avviando `wes` da solo.\n\n     wes\n\n*REP* accetta l'input dello script finché non inserisci due righe vuote. Puoi anche vedere *REP* che esegue lo script di esempio in *README.md* .\n",
                "ru": "# Применение\n\nВведите ключевое слово `wes` , а затем команду, указывающую файл, который будет отправной точкой программы для консоли. Расширение скрипта *.js* можно не указывать.\n\n     wes index\n\nКроме того, поскольку *wes* оснащен *REP* , вы можете напрямую вводить скрипты, запустив только `wes` .\n\n     wes\n\n*REP* принимает ввод сценария, пока вы не введете две пустые строки. Вы также можете увидеть, как *REP* запускает пример скрипта в *README.md* .\n",
                "ms": "# Penggunaan\n\nMasukkan kata kunci `wes` diikuti dengan arahan yang menyatakan fail yang akan menjadi titik permulaan program ke konsol. Sambungan skrip *.js* boleh diabaikan.\n\n     wes index\n\nSelain itu, memandangkan *wes* dilengkapi dengan *REP* , anda boleh memasukkan skrip terus dengan memulakan `wes` sahaja.\n\n     wes\n\n*REP* menerima input skrip sehingga anda memasukkan dua baris kosong. Anda juga boleh melihat *REP* menjalankan skrip contoh dalam *README.md* .\n",
                "nl": "# Gebruik\n\nVoer het `wes` -sleutelwoord in gevolgd door de opdracht die het bestand specificeert dat het startpunt van het programma naar de console zal zijn. De *.js* kan worden weggelaten.\n\n     wes index\n\nOmdat *wes* is uitgerust met *REP* , kunt u scripts ook rechtstreeks invoeren door alleen `wes` te starten.\n\n     wes\n\n*REP* accepteert scriptinvoer totdat u twee lege regels invoert. U kunt ook zien dat *REP* het voorbeeldscript uitvoert in *README.md* .\n",
                "ar": "# إستعمال\n\nأدخل الكلمة الأساسية `wes` متبوعة بالأمر الذي يحدد الملف الذي سيكون نقطة انطلاق البرنامج إلى وحدة التحكم. يمكن حذف ملحق البرنامج النصي *.js* .\n\n     wes index\n\nأيضًا ، نظرًا لأن *wes* مجهز بـ *REP* ، يمكنك إدخال البرامج النصية مباشرة عن طريق بدء `wes` وحده.\n\n     wes\n\nيقبل *REP* إدخال البرنامج النصي حتى تقوم بإدخال سطرين فارغين. يمكنك أيضًا رؤية *REP* يشغل مثال البرنامج النصي في *README.md* .\n",
                "bn": "# ব্যবহার\n\nফাইলটি নির্দিষ্ট করে কমান্ডটি অনুসরণ করে `wes` কীওয়ার্ড লিখুন যা কনসোলে প্রোগ্রামের শুরুর বিন্দু হবে। স্ক্রিপ্ট এক্সটেনশন *.js* বাদ দেওয়া যেতে পারে।\n\n     wes index\n\nএছাড়াও, যেহেতু *wes* *REP* দিয়ে সজ্জিত, আপনি একা `wes` শুরু করে সরাসরি স্ক্রিপ্ট লিখতে পারেন।\n\n     wes\n\nআপনি দুটি ফাঁকা লাইন প্রবেশ না করা পর্যন্ত *REP* স্ক্রিপ্ট ইনপুট গ্রহণ করে। আপনি *REP* *README.md* এ উদাহরণ স্ক্রিপ্ট চালাতেও দেখতে পারেন।\n"
            }
        },
        "## コマンドラインオプション": {
            "content": "## コマンドラインオプション\n\n*wes* の起動オプションは下記になります。\n\n| named              | Description                      |\n| ------------------ | -------------------------------- |\n| `--monotone`       | *ANSI escape code* を排除します        |\n| `--transpile`      | 常に *babel-standalone* で変換して実行します |\n| `--debug`          | スクリプトをデバッグモードで実行します              |\n| `--encoding=UTF-8` | 最初に読み込むファイルのエンコードを指定します          |\n| `--engine=Chakra`  | このオプションは *wes* によって自動で付加されます     |",
            "translated": {
                "en": "## command line options\n\n*wes* startup options are as follows.\n\n| named              | Description                                    |\n| ------------------ | ---------------------------------------------- |\n| `--monotone`       | Eliminates *ANSI escape code*                  |\n| `--transpile`      | Always convert and run with *babel-standalone* |\n| `--debug`          | run the script in debug mode                   |\n| `--encoding=UTF-8` | Specifies the encoding of the first file read  |\n| `--engine=Chakra`  | This option is added automatically by *wes*    |\n",
                "zh-CN": "## 命令行选项\n\n*wes*启动选项如下。\n\n| 命名为                | 描述                          |\n| ------------------ | --------------------------- |\n| `--monotone`       | 消除*ANSI escape code*        |\n| `--transpile`      | 始终使用*babel-standalone*转换和运行 |\n| `--debug`          | 在调试模式下运行脚本                  |\n| `--encoding=UTF-8` | 指定读取的第一个文件的编码               |\n| `--engine=Chakra`  | 此选项由*wes*自动添加               |\n",
                "zh-TW": "## 命令行選項\n\n*wes*啟動選項如下。\n\n| 命名為                | 描述                          |\n| ------------------ | --------------------------- |\n| `--monotone`       | 消除*ANSI escape code*        |\n| `--transpile`      | 始終使用*babel-standalone*轉換和運行 |\n| `--debug`          | 在調試模式下運行腳本                  |\n| `--encoding=UTF-8` | 指定讀取的第一個文件的編碼               |\n| `--engine=Chakra`  | 此選項由*wes*自動添加               |\n",
                "es": "## opciones de línea de comando\n\nLas opciones de inicio de *wes* son las siguientes.\n\n| nombrada           | Descripción                                         |\n| ------------------ | --------------------------------------------------- |\n| `--monotone`       | Elimina *ANSI escape code*                          |\n| `--transpile`      | Siempre convierta y ejecute con *babel-standalone*  |\n| `--debug`          | ejecutar el script en modo de depuración            |\n| `--encoding=UTF-8` | Especifica la codificación del primer archivo leído |\n| `--engine=Chakra`  | Esta opción es agregada automáticamente por *wes*   |\n",
                "de": "## Befehlszeilenoptionen\n\n*wes* Startoptionen sind wie folgt.\n\n| genannt            | Beschreibung                                            |\n| ------------------ | ------------------------------------------------------- |\n| `--monotone`       | Beseitigt *ANSI escape code*                            |\n| `--transpile`      | Immer konvertieren und mit *babel-standalone* ausführen |\n| `--debug`          | Führen Sie das Skript im Debug-Modus aus                |\n| `--encoding=UTF-8` | Gibt die Kodierung der ersten gelesenen Datei an        |\n| `--engine=Chakra`  | Diese Option wird automatisch von *wes* hinzugefügt     |\n",
                "fr": "## options de ligne de commande\n\nLes options de démarrage de *wes* sont les suivantes.\n\n| nommé              | La description                                         |\n| ------------------ | ------------------------------------------------------ |\n| `--monotone`       | Élimine *ANSI escape code*                             |\n| `--transpile`      | Toujours convertir et exécuter avec *babel-standalone* |\n| `--debug`          | exécuter le script en mode débogage                    |\n| `--encoding=UTF-8` | Spécifie l'encodage du premier fichier lu              |\n| `--engine=Chakra`  | Cette option est ajoutée automatiquement par *wes*     |\n",
                "hi": "## कमांड लाइन विकल्प\n\n*wes* स्टार्टअप विकल्प इस प्रकार हैं।\n\n| नामित              | विवरण                                                  |\n| ------------------ | ------------------------------------------------------ |\n| `--monotone`       | *ANSI escape code* को हटाता है                         |\n| `--transpile`      | हमेशा *babel-standalone* के साथ कनवर्ट करें और चलाएं   |\n| `--debug`          | स्क्रिप्ट को डिबग मोड में चलाएँ                        |\n| `--encoding=UTF-8` | पढ़ी गई पहली फ़ाइल के एन्कोडिंग को निर्दिष्ट करता है   |\n| `--engine=Chakra`  | यह विकल्प स्वचालित रूप से *wes* . द्वारा जोड़ा जाता है |\n",
                "pt": "## opções de linha de comando\n\nAs opções de inicialização do *wes* são as seguintes.\n\n| nomeado            | Descrição                                         |\n| ------------------ | ------------------------------------------------- |\n| `--monotone`       | Elimina *ANSI escape code*                        |\n| `--transpile`      | Sempre converta e execute com *babel-standalone*  |\n| `--debug`          | execute o script no modo de depuração             |\n| `--encoding=UTF-8` | Especifica a codificação do primeiro arquivo lido |\n| `--engine=Chakra`  | Esta opção é adicionada automaticamente por *wes* |\n",
                "it": "## opzioni della riga di comando\n\nLe opzioni di avvio di *wes* sono le seguenti.\n\n| di nome            | Descrizione                                            |\n| ------------------ | ------------------------------------------------------ |\n| `--monotone`       | Elimina *ANSI escape code*                             |\n| `--transpile`      | Converti ed esegui sempre con *babel-standalone*       |\n| `--debug`          | eseguire lo script in modalità debug                   |\n| `--encoding=UTF-8` | Specifica la codifica del primo file letto             |\n| `--engine=Chakra`  | Questa opzione viene aggiunta automaticamente da *wes* |\n",
                "ru": "## параметры командной строки\n\nВарианты запуска *wes* следующие.\n\n| по имени           | Описание                                                       |\n| ------------------ | -------------------------------------------------------------- |\n| `--monotone`       | Устраняет *ANSI escape code*                                   |\n| `--transpile`      | Всегда конвертируйте и запускайте с помощью *babel-standalone* |\n| `--debug`          | запустить скрипт в режиме отладки                              |\n| `--encoding=UTF-8` | Указывает кодировку первого прочитанного файла                 |\n| `--engine=Chakra`  | Эта опция автоматически добавляется *wes*                      |\n",
                "ms": "## pilihan baris arahan\n\nPilihan permulaan *wes* adalah seperti berikut.\n\n| bernama            | Penerangan                                            |\n| ------------------ | ----------------------------------------------------- |\n| `--monotone`       | Menghapuskan *ANSI escape code*                       |\n| `--transpile`      | Sentiasa tukar dan jalankan dengan *babel-standalone* |\n| `--debug`          | jalankan skrip dalam mod nyahpepijat                  |\n| `--encoding=UTF-8` | Menentukan pengekodan fail pertama dibaca             |\n| `--engine=Chakra`  | Pilihan ini ditambah secara automatik oleh *wes*      |\n",
                "nl": "## opdrachtregelopties\n\nDe opstartopties van *wes* zijn als volgt.\n\n| genaamd            | Beschrijving                                            |\n| ------------------ | ------------------------------------------------------- |\n| `--monotone`       | Elimineert *ANSI escape code*                           |\n| `--transpile`      | Altijd converteren en uitvoeren met *babel-standalone*  |\n| `--debug`          | voer het script uit in debug-modus                      |\n| `--encoding=UTF-8` | Specificeert de codering van het eerste gelezen bestand |\n| `--engine=Chakra`  | Deze optie wordt automatisch toegevoegd door *wes*      |\n",
                "ar": "## خيارات سطر الأوامر\n\nخيارات بدء التشغيل *wes* كما يلي.\n\n| اسم الشيئ          | وصف                                                     |\n| ------------------ | ------------------------------------------------------- |\n| `--monotone`       | يلغي *ANSI escape code*                                 |\n| `--transpile`      | قم دائمًا بالتحويل والتشغيل باستخدام *babel-standalone* |\n| `--debug`          | قم بتشغيل البرنامج النصي في وضع التصحيح                 |\n| `--encoding=UTF-8` | يحدد ترميز أول ملف تمت قراءته                           |\n| `--engine=Chakra`  | هذا الخيار يضاف تلقائيا من قبل *wes*                    |\n",
                "bn": "## কমান্ড লাইন বিকল্প\n\n*wes* স্টার্টআপ বিকল্পগুলি নিম্নরূপ।\n\n| নাম                | বর্ণনা                                                 |\n| ------------------ | ------------------------------------------------------ |\n| `--monotone`       | *ANSI escape code* বাদ দেয়                            |\n| `--transpile`      | সর্বদা রূপান্তর করুন এবং *babel-standalone* সাথে চালান |\n| `--debug`          | ডিবাগ মোডে স্ক্রিপ্ট চালান                             |\n| `--encoding=UTF-8` | পড়া প্রথম ফাইলের এনকোডিং নির্দিষ্ট করে                |\n| `--engine=Chakra`  | এই বিকল্পটি *wes* দ্বারা স্বয়ংক্রিয়ভাবে যোগ করা হয়  |\n"
            }
        },
        "# モジュールシステム": {
            "content": "# モジュールシステム\n\n*wes* は `require()` を使用する *commonjs module* のシステムと `import` を使用する *es module* の２つのモジュールシステムに対応しています。(*dynamic import* は非同期処理の為、対応していません)",
            "translated": {
                "en": "# module system\n\n*wes* supports two module systems, the *commonjs module* system using `require()` and the *es module* system using `import` . ( *dynamic import* is not supported because it is an asynchronous process)\n",
                "zh-CN": "# 模块系统\n\n*wes*支持两个模块系统，使用`require()`的*commonjs module*系统和使用`import`的*es module*系统。 （不支持*dynamic import* ，因为它是一个异步过程）\n",
                "zh-TW": "# 模塊系統\n\n*wes*支持兩個模塊系統，使用`require()`的*commonjs module*系統和使用`import`的*es module*系統。 （不支持*dynamic import* ，因為它是一個異步過程）\n",
                "es": "# sistema de módulos\n\n*wes* admite dos sistemas de módulos, el sistema *commonjs module* que usa `require()` y el sistema de *es module* que usa `import` . ( *dynamic import* no es compatible porque es un proceso asíncrono)\n",
                "de": "# Modulsystem\n\n*wes* unterstützt zwei Modulsysteme, das *commonjs module* mit `require()` und das *es module* mit `import` . ( *dynamic import* wird nicht unterstützt, da es sich um einen asynchronen Prozess handelt)\n",
                "fr": "# système de modules\n\n*wes* prend en charge deux systèmes de modules, le système de *commonjs module* utilisant `require()` et le système de *es module* utilisant les `import` . ( *dynamic import* n'est pas prise en charge car il s'agit d'un processus asynchrone)\n",
                "hi": "# मॉड्यूल प्रणाली\n\n*wes* दो मॉड्यूल सिस्टम का समर्थन करता है, `require()` का उपयोग कर *commonjs module* सिस्टम और `import` का उपयोग कर *es module* सिस्टम। ( *dynamic import* समर्थित नहीं है क्योंकि यह एक अतुल्यकालिक प्रक्रिया है)\n",
                "pt": "# sistema de módulos\n\n*wes* suporta dois sistemas de módulos, o sistema *commonjs module* usando `require()` e o sistema de *es module* usando `import` . ( *dynamic import* não é suportada porque é um processo assíncrono)\n",
                "it": "# sistema di moduli\n\n*wes* supporta due sistemi di moduli, il sistema *commonjs module* che utilizza `require()` e il sistema di *es module* che utilizza `import` . (l' *dynamic import* non è supportata perché è un processo asincrono)\n",
                "ru": "# модульная система\n\n*wes* поддерживает две модульные системы: *commonjs module* с использованием `require()` и *es module* с использованием `import` . ( *dynamic import* не поддерживается, поскольку это асинхронный процесс)\n",
                "ms": "# sistem modul\n\n*wes* menyokong dua sistem modul, sistem *commonjs module* menggunakan `require()` dan sistem *es module* menggunakan `import` . ( *dynamic import* tidak disokong kerana ia adalah proses tak segerak)\n",
                "nl": "# module systeem\n\n*wes* ondersteunt twee modulesystemen, het *commonjs module* dat gebruikmaakt van required `require()` en het *es module* dat `import` gebruikt. ( *dynamic import* wordt niet ondersteund omdat het een asynchroon proces is)\n",
                "ar": "# نظام الوحدة\n\nيدعم *wes* نظامين للوحدات النمطية ، وهما نظام *commonjs module* باستخدام `require()` ونظام *es module* باستخدام `import` . ( *dynamic import* غير مدعوم لأنه عملية غير متزامنة)\n",
                "bn": "# মডিউল সিস্টেম\n\n*wes* দুটি মডিউল সিস্টেম সমর্থন করে, *commonjs module* সিস্টেম `require()` ব্যবহার করে এবং *es module* সিস্টেম `import` ব্যবহার করে। ( *dynamic import* সমর্থিত নয় কারণ এটি একটি অ্যাসিঙ্ক্রোনাস প্রক্রিয়া)\n"
            }
        },
        "## *commonjs module*": {
            "content": "## *commonjs module*\n\n`module.exports` への代入と `require()` での呼び出しでモジュールを管理します。\n絶対パスと `./` と `../` から始まる相対パス以外のパスは *wes\\_modules* ディレクトリと\n利便上 *node\\_modules* ディレクトリからモジュールを探します。\n*wes* の `require()` はモジュールファイルのエンコードを自動推測しますが、\n正しく推測しない場合に第二引数でエンコードを指定も可能です。\n\n```javascript\n// ./add.js\nfunction add (a, b) {\n    return a + b\n}\nmodule.exports = add\n```\n\n```javascript\n// ./main.js\nconst add = require('./add')\nconsole.log('add(7, 3) // => %O', add(7, 3))\n```\n\nまた、`require('WScript.Shell')` の様に *COM Object* に対しても *require* でインポート可能です。\n\n```javascript\nconst Shell = require('Shell.Application')\nShell.MinimizeAll()\nWScript.Sleep(2000)\nShell.UndoMinimizeAll()\n```",
            "translated": {
                "en": "## *commonjs module*\n\nManage modules by assigning to `module.exports` and calling `require()` . Paths other than absolute paths and relative paths starting with `./` and `../` look for modules in the *wes\\_modules* directory and conveniently the *node\\_modules* directory. *wes* 's `require()` automatically guesses the encoding of the module file, but you can specify the encoding with the second argument if it doesn't guess correctly.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nAlso, it is possible to import with *require* for *COM Object* like `require('WScript.Shell')` .\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "zh-CN": "## *commonjs module*\n\n通过分配给`module.exports`并调用`require()`来管理模块。以`./`和`../`开头的绝对路径和相对路径以外的路径在*wes\\_modules*目录和*node\\_modules*目录中查找模块。 *wes*的`require()`会自动猜测模块文件的编码，但如果没有正确猜测，您可以使用第二个参数指定编码。\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\n此外，还可以使用*require* `require('WScript.Shell')`类的*COM Object*导入。\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "zh-TW": "## *commonjs module*\n\n通過分配給`module.exports`並調用`require()`來管理模塊。絕對路徑和以`./`和`../`開頭的相對路徑以外的路徑在*wes\\_modules*目錄中查找模塊，並且方便地在*node\\_modules*目錄中查找。 *wes*的`require()`會自動猜測模塊文件的編碼，但如果猜測不正確，您可以使用第二個參數指定編碼。\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\n此外，還可以使用*require* `require('WScript.Shell')`類的*COM Object*導入。\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "es": "## *commonjs module*\n\nAdministre módulos asignándolos a `module.exports` y llamando a `require()` . Las rutas que no sean rutas absolutas y rutas relativas que comiencen con `./` y `../` busquen módulos en el directorio *wes\\_modules* y convenientemente en el directorio *node\\_modules* . El `require()` de *wes* adivina automáticamente la codificación del archivo del módulo, pero puede especificar la codificación con el segundo argumento si no adivina correctamente.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nAdemás, es posible importar con *require* para *COM Object* como `require('WScript.Shell')` .\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "de": "## *commonjs module*\n\nVerwalten Sie Module, indem `module.exports` und `require()` aufrufen. Andere Pfade als absolute Pfade und relative Pfade, die mit `./` und `../` beginnen, suchen nach Modulen im Verzeichnis *wes\\_modules* und praktischerweise im Verzeichnis *node\\_modules* . *wes* `require()` errät automatisch die Codierung der Moduldatei, aber Sie können die Codierung mit dem zweiten Argument angeben, wenn es nicht richtig rät.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nAußerdem ist es möglich, mit *require* für *COM Object* wie `require('WScript.Shell')` zu importieren.\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "fr": "## *commonjs module*\n\nGérez les modules en attribuant à `module.exports` et en appelant `require()` . Les chemins autres que les chemins absolus et les chemins relatifs commençant par `./` ​​et `../` recherchent les modules dans le répertoire *wes\\_modules* et commodément le répertoire *node\\_modules* . Le `require()` de *wes* devine automatiquement l'encodage du fichier de module, mais vous pouvez spécifier l'encodage avec le deuxième argument s'il ne devine pas correctement.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nEn outre, il est possible d'importer avec *require* pour un *COM Object* comme `require('WScript.Shell')` .\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "hi": "## *commonjs module*\n\nमॉड्यूल को असाइन करके मॉड्यूल प्रबंधित करें। `module.exports` और कॉल `require()` । `./` और `../` से शुरू होने वाले निरपेक्ष पथों और सापेक्ष पथों के अलावा पथ, *wes\\_modules* निर्देशिका में मॉड्यूल की तलाश करते हैं और आसानी से *node\\_modules* निर्देशिका। *wes* की `require()` स्वचालित रूप से मॉड्यूल फ़ाइल के एन्कोडिंग का अनुमान लगाती है, लेकिन यदि आप सही ढंग से अनुमान नहीं लगाते हैं तो आप दूसरे तर्क के साथ एन्कोडिंग निर्दिष्ट कर सकते हैं।\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nसाथ ही, *COM Object* के लिए *require* के साथ आयात करना संभव है जैसे `require('WScript.Shell')` ।\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "pt": "## *commonjs module*\n\nGerencie módulos atribuindo a `module.exports` e chamando `require()` . Caminhos diferentes de caminhos absolutos e caminhos relativos começando com `./` e `../` procuram módulos no diretório *wes\\_modules* e convenientemente no diretório *node\\_modules* . O `require()` de *wes* adivinha automaticamente a codificação do arquivo do módulo, mas você pode especificar a codificação com o segundo argumento se não adivinhar corretamente.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nAlém disso, é possível importar com *require* para *COM Object* como `require('WScript.Shell')` .\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "it": "## *commonjs module*\n\nGestisci i moduli assegnandoli a `module.exports` e chiamando `require()` . Percorsi diversi dai percorsi assoluti e dai percorsi relativi che iniziano con `./` e `../` cercano i moduli nella directory *wes\\_modules* e convenientemente nella directory *node\\_modules* . `require()` di *wes* indovina automaticamente la codifica del file del modulo, ma puoi specificare la codifica con il secondo argomento se non indovina correttamente.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nInoltre, è possibile importare con *require* per *COM Object* come `require('WScript.Shell')` .\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "ru": "## *commonjs module*\n\nУправляйте модулями, назначая `module.exports` и вызывая `require()` . Пути, отличные от абсолютных путей и относительных путей, начинающихся с `./` и `../` , ищут модули в каталоге *wes\\_modules* и, удобно, в *node\\_modules* . *wes* 's `require()` автоматически угадывает кодировку файла модуля, но вы можете указать кодировку вторым аргументом, если она не угадывается правильно.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nКроме того, можно импортировать с помощью *require* для *COM Object* , например `require('WScript.Shell')` .\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "ms": "## *commonjs module*\n\nUrus modul dengan memberikan kepada `module.exports` dan memanggil `require()` . Laluan selain daripada laluan mutlak dan laluan relatif bermula dengan `./` dan `../` cari modul dalam direktori *wes\\_modules* dan dengan mudah direktori *node\\_modules* . *wes* `require()` secara automatik meneka pengekodan fail modul, tetapi anda boleh menentukan pengekodan dengan hujah kedua jika ia tidak meneka dengan betul.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nJuga, adalah mungkin untuk mengimport dengan *require* untuk *COM Object* seperti `require('WScript.Shell')` .\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "nl": "## *commonjs module*\n\nBeheer modules door deze toe te wijzen aan `module.exports` en request `require()` aan te roepen. Andere paden dan absolute paden en relatieve paden die beginnen met `./` en `../` zoeken naar modules in de map *wes\\_modules* en handig in de map *node\\_modules* . *wes* 's `require()` raadt automatisch de codering van het modulebestand, maar je kunt de codering specificeren met het tweede argument als het niet correct raadt.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nHet is ook mogelijk om te importeren met *require* voor *COM Object* zoals `require('WScript.Shell')` .\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "ar": "## *commonjs module*\n\nإدارة الوحدات عن طريق التخصيص إلى `module.exports` `require()` . المسارات بخلاف المسارات المطلقة والمسارات النسبية التي تبدأ بـ `./` و `../` ابحث عن الوحدات النمطية في دليل *wes\\_modules* وبشكل ملائم في دليل *node\\_modules* . يقوم *wes* `require()` تلقائيًا بتخمين ترميز ملف الوحدة النمطية ، ولكن يمكنك تحديد الترميز باستخدام الوسيطة الثانية إذا لم يتم التخمين بشكل صحيح.\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nأيضًا ، من الممكن الاستيراد مع *require* *COM Object* مثل `require('WScript.Shell')` .\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n",
                "bn": "## *commonjs module*\n\n`module.exports` বরাদ্দ করে এবং `require()` কল করে মডিউল পরিচালনা করুন। পরম পাথ এবং `./` এবং `../` দিয়ে শুরু হওয়া আপেক্ষিক পাথগুলি ছাড়া অন্য পাথগুলি *wes\\_modules* ডিরেক্টরিতে এবং সুবিধামত *node\\_modules* ডিরেক্টরিতে মডিউলগুলি সন্ধান করে৷ *wes* 's `require()` স্বয়ংক্রিয়ভাবে মডিউল ফাইলের এনকোডিং অনুমান করে, কিন্তু আপনি দ্বিতীয় আর্গুমেন্টের সাথে এনকোডিং নির্দিষ্ট করতে পারেন যদি এটি সঠিকভাবে অনুমান না করে।\n\n     // ./add.js function add (a, b) { return ab } module.exports = add\n\n<!---->\n\n     // ./main.js const add = require('./add') console.log('add(7, 3) // => %O', add(7, 3))\n\nএছাড়াও, `require('WScript.Shell')` মতো *COM Object* *require* সাথে আমদানি করা সম্ভব।\n\n     const Shell = require('Shell.Application') Shell.MinimizeAll() WScript.Sleep(2000) Shell.UndoMinimizeAll()\n"
            }
        },
        "## *es module*": {
            "content": "## *es module*\n\nスクリプトの実行エンジンである *Chakra* は `imoprt` などの構文を解釈しますが `cscript` としての処理方法が定義されていないのか、そのままでは実行できません。\n*wes* では *babel* をビルトインモジュールに加えることで、*es module* に対しても逐次トランスパイルしながら実行しています。そのためコストとして処理のオーバーヘッドと *wes.js* ファイルが肥大化しています。\n*es module* で記述されているモジュールもトランスパイルで `require()` に変換されるため、*COM Object* の呼び出しも可能です。\nしかしながら *es module* でのモジュールファイルのエンコード指定には対応していません。全て自動推測で読み込まれます。\n*es module* として読み込ませるには拡張子を `.mjs` にするか `package.json` の `\"type\"` フィールドを `\"module\"` にしてください。\n\n```javascript\n// ./sub.mjs\nexport default function sub (a, b) {\n    return a - b\n}\n```\n\n```javascript\n// ./main2.js\nimport sub from './sub.mjs'\nconsole.log('sub(7, 3) // => %O', sub(7, 3))\n```",
            "translated": {
                "en": "## *es module*\n\n*Chakra* , which is the script execution engine, interprets syntax such as `imoprt` , but it cannot be executed as it is because the processing method as `cscript` is not defined. In *wes* , by adding *babel* to the built-in modules, *es module* are also executed while being transpiled one by one. This costs us processing overhead and a bloated *wes.js* file. Modules written in *es module* are also converted to `require()` by transpiling, so it is possible to call *COM Object* . However, it does not support specifying the encoding of the module file with *es module* . Everything is loaded automatically. To load it as an *es module* , set the extension to `.mjs` or set the `\"type\"` field in `package.json` to `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "zh-CN": "## *es module*\n\n*Chakra*是一个脚本执行引擎，可以解释诸如`imoprt`之类的语法，但由于没有定义`cscript`的处理方法，因此无法按原样执行。在*wes*中，通过在内置模块中添加*babel* ， *es module*也在被顺序转译的同时执行。这会花费我们处理开销和臃肿的*wes.js*文件。 *es module*中写的模块也通过转译转换为`require()` ，因此可以调用*COM Object* 。但是，它不支持使用*es module*指定模块文件的编码。一切都是自动加载的。要将其加载为*es module* ，请将扩展名设置为`.mjs`或将`package.json`中的`\"type\"`字段设置为`\"module\"` 。\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "zh-TW": "## *es module*\n\n腳本執行引擎*Chakra*解釋了諸如`imoprt`之類的語法，但由於未定義`cscript`的處理方法，因此無法按原樣執行。在*wes*中，通過在內置模塊中添加*babel* ， *es module*也在被一個一個轉譯的同時執行。這會花費我們處理開銷和臃腫的*wes.js*文件。 *es module*中寫的模塊也通過轉譯轉換為`require()` ，因此可以調用*COM Object* 。但是，它不支持使用*es module*指定模塊文件的編碼。一切都是自動加載的。要將其加載為*es module* ，請將擴展名設置為`.mjs`或將`package.json`中的`\"type\"`字段設置為`\"module\"` 。\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "es": "## *es module*\n\n*Chakra* , que es un motor de ejecución de scripts, interpreta sintaxis como `imoprt` , pero no se puede ejecutar tal cual porque el método de procesamiento como `cscript` no está definido. En *wes* , al agregar *babel* a los módulos incorporados, *es module* es también se ejecutan mientras se transpilan secuencialmente. Esto nos cuesta la sobrecarga de procesamiento y un archivo *wes.js* . Los módulos escritos en el *es module* es también se convierten a `require()` mediante la transpilación, por lo que es posible llamar a *COM Object* . Sin embargo, no admite especificar la codificación del archivo del módulo con el *es module* . Todo se carga automáticamente. Para cargarlo como un *es module* , configure la extensión en `.mjs` o configure el campo `\"type\"` en `package.json` en `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "de": "## *es module*\n\n*Chakra* , die Skriptausführungs-Engine, interpretiert Syntax wie `imoprt` , kann jedoch nicht unverändert ausgeführt werden, da die Verarbeitungsmethode als `cscript` nicht definiert ist. In *wes* werden durch Hinzufügen von *babel* zu den eingebauten Modulen auch *es module* ausgeführt, während sie einzeln transpiliert werden. Dies kostet uns Verarbeitungsaufwand und eine aufgeblähte *wes.js* -Datei. Module, die in *es module* geschrieben wurden, werden durch Transpilieren ebenfalls in `require()` konvertiert, sodass es möglich ist, *COM Object* aufzurufen. Es unterstützt jedoch nicht die Angabe der Codierung der Moduldatei mit *es module* . Alles wird automatisch geladen. Um es als *es module* zu laden, setzen Sie die Erweiterung auf `.mjs` oder setzen Sie das Feld `\"type\"` in `package.json` auf `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "fr": "## *es module*\n\n*Chakra* , qui est un moteur d'exécution de script, interprète une syntaxe telle que `imoprt` , mais il ne peut pas être exécuté tel quel car la méthode de traitement en tant que `cscript` n'est pas définie. Dans *wes* , en ajoutant *babel* aux modules intégrés, les modules *es module* sont également exécutés tout en étant séquentiellement transpilés. Cela nous coûte des frais généraux de traitement et un fichier *wes.js* gonflé. Les modules écrits dans le *es module* sont également convertis en `require()` par transpilation, il est donc possible d'appeler *COM Object* . Cependant, il ne prend pas en charge la spécification de l'encodage du fichier de module avec *es module* . Tout est chargé automatiquement. Pour le charger en tant que *es module* , définissez l'extension sur `.mjs` ou définissez le champ `\"type\"` dans `package.json` sur `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "hi": "## *es module*\n\n*Chakra* , जो एक स्क्रिप्ट निष्पादन इंजन है, सिंटैक्स की व्याख्या करता है जैसे कि `imoprt` , लेकिन इसे निष्पादित नहीं किया जा सकता क्योंकि ऐसा इसलिए है क्योंकि `cscript` के रूप में प्रसंस्करण विधि परिभाषित नहीं है। *wes* में, बिल्ट-इन मॉड्यूल में बेबेल को जोड़कर, *es module* को क्रमिक रूप से *babel* किए जाने के दौरान भी निष्पादित किया जाता है। यह हमें ओवरहेड और एक फूली *wes.js* फ़ाइल को संसाधित करने में खर्च करता है। *es module* में लिखे गए मॉड्यूल को ट्रांसपिलिंग द्वारा `require()` में भी परिवर्तित किया जाता है, इसलिए *COM Object* को कॉल करना संभव है। हालांकि, यह *es module* के साथ मॉड्यूल फ़ाइल के एन्कोडिंग को निर्दिष्ट करने का समर्थन नहीं करता है। सब कुछ अपने आप लोड हो जाता है। इसे *es module* के रूप में लोड करने के लिए, एक्सटेंशन को `.mjs` पर सेट करें या `package.json` में `\"type\"` फ़ील्ड को `\"module\"` पर सेट करें।\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "pt": "## *es module*\n\n*Chakra* , que é um mecanismo de execução de scripts, interpreta sintaxe como `imoprt` , mas não pode ser executado porque o método de processamento como `cscript` não está definido. Em *wes* , adicionando *babel* aos módulos embutidos, os módulos *es module* também são executados enquanto são transpilados sequencialmente. Isso nos custa a sobrecarga de processamento e um arquivo *wes.js* inchado. Módulos escritos no *es module* também são convertidos para `require()` por transpilação, então é possível chamar *COM Object* . No entanto, ele não suporta especificar a codificação do arquivo de módulo com *es module* . Tudo é carregado automaticamente. Para carregá-lo como um *es module* , defina a extensão para `.mjs` ou defina o campo `\"type\"` em `package.json` para `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "it": "## *es module*\n\n*Chakra* , che è un motore di esecuzione di script, interpreta la sintassi come `imoprt` , ma non può essere eseguito così com'è perché il metodo di elaborazione come `cscript` non è definito. In *wes* , aggiungendo *babel* ai moduli integrati, anche *es module* vengono eseguiti mentre vengono trasposti in sequenza. Questo ci costa un sovraccarico di elaborazione e un file *wes.js* gonfio. I moduli scritti in *es module* vengono anche convertiti in `require()` tramite transpilazione, quindi è possibile chiamare *COM Object* . Tuttavia, non supporta la specifica della codifica del file del modulo con *es module* . Tutto viene caricato automaticamente. Per caricarlo come *es module* , imposta l'estensione su `.mjs` o imposta il campo `\"type\"` in `package.json` su `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "ru": "## *es module*\n\n*Chakra* , механизм выполнения сценариев, интерпретирует такой синтаксис, как `imoprt` , но он не может быть выполнен в том виде, в каком он есть, поскольку метод обработки как `cscript` не определен. В *wes* , добавляя *babel* к встроенным модулям, модули *es module* также выполняются при последовательной транспиляции. Это стоит нам накладных расходов на обработку и раздутого файла *wes.js* Модули, написанные в *es module* , также преобразуются в `require()` путем транспиляции, поэтому можно вызывать *COM Object* . Однако он не поддерживает указание кодировки файла модуля с помощью *es module* . Все загружается автоматически. Чтобы загрузить его как *es module* , установите расширение `.mjs` или установите для поля `\"type\"` в `package.json` значение `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "ms": "## *es module*\n\n*Chakra* , yang merupakan enjin pelaksanaan skrip, mentafsir sintaks seperti `imoprt` , tetapi ia tidak boleh dilaksanakan kerana kaedah pemprosesan sebagai `cscript` tidak ditakrifkan. Di *wes* , dengan menambahkan *babel* pada modul terbina dalam, modul *es module* juga dilaksanakan semasa ditranspil secara berurutan. Ini membebankan kami memproses overhed dan fail *wes.js* yang kembung. Modul yang ditulis dalam *es module* juga ditukar kepada `require()` dengan mengalihkan, jadi adalah mungkin untuk memanggil *COM Object* . Walau bagaimanapun, ia tidak menyokong menentukan pengekodan fail modul dengan *es module* . Semuanya dimuatkan secara automatik. Untuk memuatkannya sebagai *es module* , tetapkan sambungan kepada `.mjs` atau tetapkan medan `\"type\"` dalam `package.json` kepada `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "nl": "## *es module*\n\n*Chakra* , een scriptuitvoeringsengine, interpreteert syntaxis zoals `imoprt` , maar het kan niet worden uitgevoerd zoals het is omdat de verwerkingsmethode als `cscript` niet is gedefinieerd. In *wes* , door *babel* toe te voegen aan de ingebouwde modules, worden *es module* ook uitgevoerd terwijl ze sequentieel worden getranspileerd. Dit kost ons verwerkingskosten en een opgeblazen *wes.js* -bestand. Modules die in de *es module* zijn geschreven, worden ook geconverteerd naar required `require()` door te transpileren, dus het is mogelijk om *COM Object* aan te roepen. Het ondersteunt echter niet het specificeren van de codering van het modulebestand met *es module* . Alles wordt automatisch geladen. Om het als een *es module* te laden, stelt u de extensie in op `.mjs` of stelt u het veld `\"type\"` in `package.json` in op `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "ar": "## *es module*\n\n*Chakra* ، وهو محرك تنفيذ نصي ، يفسر بناء الجملة مثل `imoprt` ، لكن لا يمكن تنفيذه كما هو لأن طريقة المعالجة مثل `cscript` غير محددة. في *wes* ، من خلال إضافة *babel* إلى الوحدات المدمجة ، يتم أيضًا تنفيذ *es module* أثناء نقلها بالتسلسل. هذا يكلفنا معالجة النفقات العامة وملف *wes.js* المتضخم. يتم أيضًا تحويل الوحدات المكتوبة في *es module* إلى `require()` عن طريق التحويل ، لذلك من الممكن استدعاء *COM Object* . ومع ذلك ، فإنه لا يدعم تحديد ترميز ملف الوحدة النمطية باستخدام *es module* . يتم تحميل كل شيء تلقائيًا. لتحميلها كوحدة *es module* ، اضبط الامتداد على `.mjs` أو اضبط حقل `\"type\"` في `package.json` على `\"module\"` .\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n",
                "bn": "## *es module*\n\n*Chakra* , যা স্ক্রিপ্ট এক্সিকিউশন ইঞ্জিন, সিনট্যাক্সকে ব্যাখ্যা করে যেমন `imoprt` , কিন্তু এটি কার্যকর করা যায় না কারণ এটি `cscript` হিসাবে প্রক্রিয়াকরণ পদ্ধতি সংজ্ঞায়িত করা হয়নি। *wes* এ, অন্তর্নির্মিত মডিউলগুলিতে *babel* যোগ করার মাধ্যমে, *es module* একের পর এক স্থানান্তরিত হওয়ার সময় কার্যকর করা হয়। এটি আমাদের ওভারহেড এবং একটি ফুলে যাওয়া *wes.js* ফাইল প্রক্রিয়াকরণের জন্য খরচ করে। *es module* লেখা মডিউলগুলিকেও ট্রান্সপিলিং করে `require()` এ রূপান্তরিত করা হয়, তাই *COM Object* অবজেক্টকে কল করা সম্ভব। যাইহোক, এটি *es module* সহ মডিউল ফাইলের এনকোডিং নির্দিষ্ট করা সমর্থন করে না। সবকিছু স্বয়ংক্রিয়ভাবে লোড হয়. এটিকে একটি *es module* হিসাবে লোড করতে, .mjs এ এক্সটেনশন সেট করুন বা `.mjs` এ `\"type\"` ক্ষেত্রটিকে `\"module\"` এ `package.json` করুন।\n\n     // ./sub.mjs export default function sub (a, b) { return a - b }\n\n<!---->\n\n     // ./main2.js import sub from './sub.mjs' console.log('sub(7, 3) // => %O', sub(7, 3))\n"
            }
        },
        "# ビルトインオブジェクト": {
            "content": "# ビルトインオブジェクト\n\n*wes* は *WSH (JScript)* には無い *built-in objects* があります。",
            "translated": {
                "en": "# built-in object\n\n*wes* has *built-in objects* not found in *WSH (JScript)* .\n",
                "zh-CN": "# 内置对象\n\n*wes*有*WSH (JScript)*中没有的*built-in objects* 。\n",
                "zh-TW": "# 內置對象\n\n*wes*有*WSH (JScript)*中沒有的*built-in objects* 。\n",
                "es": "# objeto incorporado\n\n*wes* tiene *built-in objects* no se encuentran en *WSH (JScript)* .\n",
                "de": "# eingebautes Objekt\n\n*wes* hat *built-in objects* , die in *WSH (JScript)* nicht gefunden werden.\n",
                "fr": "# objet incorporé\n\n*wes* a *built-in objects* introuvables dans *WSH (JScript)* .\n",
                "hi": "# अंतर्निहित वस्तु\n\n*wes* में *WSH (JScript)* *built-in objects* नहीं मिले हैं।\n",
                "pt": "# objeto embutido\n\n*wes* tem *built-in objects* internos não encontrados no *WSH (JScript)* .\n",
                "it": "# oggetto incorporato\n\n*wes* ha *built-in objects* non trovati in *WSH (JScript)* .\n",
                "ru": "# встроенный объект\n\n*wes* имеет *built-in objects* , которых нет в *WSH (JScript)* .\n",
                "ms": "# objek terbina dalam\n\n*wes* mempunyai *built-in objects* tidak ditemui dalam *WSH (JScript)* .\n",
                "nl": "# ingebouwd object\n\n*wes* heeft *built-in objects* niet worden gevonden in *WSH (JScript)* .\n",
                "ar": "# كائن مدمج\n\nيحتوي *wes* *built-in objects* مضمنة غير موجودة في *WSH (JScript)* .\n",
                "bn": "# অন্তর্নির্মিত বস্তু\n\n*wes* এর *built-in objects* রয়েছে *WSH (JScript)* এ পাওয়া যায় নি।\n"
            }
        },
        "## *console*": {
            "content": "## *console*\n\n*wes* では `WScript.Echo` や `WScript.StdErr.WriteLine` の代わりに *console* を使用します。\n\n### *console.log()*\n\n`console.log` でコンソールに文字を出力します。また書式化文字列にも対応しています。\n書式化演算子 `%` 使用して書式化文字列を出力します。\n\n```javascript\nconsole.log(`item: %j`,  {name: 'apple', id: '001', price: 120 })\n```\n\n| Format specifier | Description                      |\n| ---------------- | -------------------------------- |\n| `%s`             | `String(value)`                  |\n| `%S`             | `String(value)`                  |\n| `%c`             | `String(value)`                  |\n| `%C`             | `String(value)`                  |\n| `%d`             | `parseInt(value, 10)`            |\n| `%D`             | `parseInt(value, 10)`            |\n| `%f`             | `Number(value)`                  |\n| `%F`             | `Number(value)`                  |\n| `%j`             | `JSON.stringify(value)`          |\n| `%J`             | `JSON.stringify(value, null, 2)` |\n| `%o`             | オブジェクトのダンプ                       |\n| `%O`             | オブジェクトのダンプ（インデント・カラフル）           |\n\n*wes* では色付き文字列を出力する為に `WScript.StdOut.WriteLine` ではなく、`WScript.StdErr.WriteLine` を使用します。\n`WScript.Echo` や `WScript.StdOut.WriteLine` は出力を遮断されています。`WScript.StdErr.WriteLine` もしくは `console.log` を使用してください。\n\n### *console.print()*\n\n通常 `console.log()` は最後に改行を含みますが、`console.print` は改行を含みません。\n\n### *console.debug()*\n\n`--debug` オプションが有効な場合のみコンソールに出力されます。\n\n### *console.error()*\n\n内容をメッセージとして例外を投げます。\n\n### *console.weaklog()*\n\n`console.weaklog()` で出力された文字列は、後続する出力がある場合にコンソールから消えます。\n出力を入れ替える場合に活用します。",
            "translated": {
                "en": "undefined\n",
                "zh-CN": "undefined\n",
                "zh-TW": "undefined\n",
                "es": "undefined\n",
                "de": "undefined\n",
                "fr": "undefined\n",
                "hi": "undefined\n",
                "pt": "undefined\n",
                "it": "undefined\n",
                "ru": "undefined\n",
                "ms": "undefined\n",
                "nl": "undefined\n",
                "ar": "undefined\n",
                "bn": "undefined\n"
            }
        },
        "## *Buffer*": {
            "content": "## *Buffer*\n\nバッファーを扱うことができます。\n\n```javascript\nconst content = 'Hello World'\nconst buff = Buffer.from(content)\nconsole.log(`${content} %O`, buff)\n```",
            "translated": {
                "en": "## *Buffer*\n\nYou can handle buffers.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "zh-CN": "## *Buffer*\n\n您可以处理缓冲区。\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "zh-TW": "## *Buffer*\n\n您可以處理緩衝區。\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "es": "## *Buffer*\n\nPuede manejar búferes.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "de": "## *Buffer*\n\nSie können mit Puffern umgehen.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "fr": "## *Buffer*\n\nVous pouvez gérer les tampons.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "hi": "## *Buffer*\n\nआप बफ़र्स को संभाल सकते हैं।\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "pt": "## *Buffer*\n\nVocê pode lidar com buffers.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "it": "## *Buffer*\n\nPuoi gestire i buffer.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "ru": "## *Buffer*\n\nВы можете обрабатывать буферы.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "ms": "## *Buffer*\n\nAnda boleh mengendalikan penimbal.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "nl": "## *Buffer*\n\nJe kunt omgaan met buffers.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "ar": "## *Buffer*\n\nيمكنك التعامل مع المخازن المؤقتة.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n",
                "bn": "## *Buffer*\n\nআপনি বাফার পরিচালনা করতে পারেন.\n\n     const content = 'Hello World' const buff = Buffer.from(content) console.log(`${content} %O`, buff)\n"
            }
        },
        "## `__dirname` and `__filename`": {
            "content": "## `__dirname` and `__filename`\n\n`__filename` は現在実行しているモジュールファイルのパスが格納されています。\n`__dirname` は `__filename` のディレクトリが格納されています。\n\n```javascript\nconsole.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n```",
            "translated": {
                "en": "## `__dirname` and `__filename`\n\n`__filename` stores the path of the currently executing module file. `__dirname` contains the directory of `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "zh-CN": "## `__dirname`和`__filename`\n\n`__filename`存储当前执行的模块文件的路径。 `__dirname`包含`__filename`的目录。\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "zh-TW": "## `__dirname`和`__filename`\n\n`__filename`存儲當前執行的模塊文件的路徑。 `__dirname`包含`__filename`的目錄。\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "es": "## `__dirname` y `__filename`\n\n`__filename` almacena la ruta del archivo del módulo que se está ejecutando actualmente. `__dirname` contiene el directorio de `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "de": "## `__dirname` und `__filename`\n\n`__filename` speichert den Pfad der aktuell ausgeführten Moduldatei. `__dirname` enthält das Verzeichnis von `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "fr": "## `__dirname` et `__filename`\n\n`__filename` stocke le chemin du fichier de module en cours d'exécution. `__dirname` contient le répertoire de `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "hi": "## `__dirname` और `__filename`\n\n`__filename` वर्तमान में निष्पादित मॉड्यूल फ़ाइल का पथ संग्रहीत करता है। `__dirname` में `__filename` की निर्देशिका है।\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "pt": "## `__dirname` e `__filename`\n\n`__filename` armazena o caminho do arquivo de módulo atualmente em execução. `__dirname` contém o diretório de `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "it": "## `__dirname` e `__filename`\n\n`__filename` memorizza il percorso del file del modulo attualmente in esecuzione. `__dirname` contiene la directory di `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "ru": "## `__dirname` и `__filename`\n\n`__filename` хранит путь к текущему исполняемому файлу модуля. `__dirname` содержит каталог `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "ms": "## `__dirname` dan `__filename`\n\n`__filename` menyimpan laluan fail modul yang sedang dilaksanakan. `__dirname` mengandungi direktori `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "nl": "## `__dirname` en `__filename`\n\n`__filename` slaat het pad op van het momenteel uitgevoerde modulebestand. `__dirname` bevat de directory van `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "ar": "## `__dirname` و `__filename`\n\n`__filename` يخزن مسار ملف الوحدة النمطية الجاري تنفيذه. يحتوي `__dirname` على دليل `__filename` .\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n",
                "bn": "## `__dirname` এবং `__filename`\n\n`__filename` বর্তমানে কার্যকর করা মডিউল ফাইলের পথ সংরক্ষণ করে। `__dirname` এ `__filename` এর ডিরেক্টরি রয়েছে।\n\n     console.log('dirname: %O\\nfilename: %O', __dirname, __filename)\n"
            }
        },
        "## *setTimeout* *setInterval* *setImmediate* *Promise*": {
            "content": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\n*wes* は同期処理の実行環境なので、*setTimeout* *setInterval* *setImmediate*  *Promise* は\n非同期処理として機能しませんが、*Promise* の実装が前提のモジュールの対応の為に実装しています。\n\n```javascript\nconst example = () => {\n  const promise = new Promise((resolve, reject) => {\n    console.log('promise')\n\n    setTimeout(() => {\n      console.log('setTimeout') \n      resolve('resolved');\n    }, 2000);\n  }).then((val) => {\n    console.log(val)\n  });\n  console.log('sub')\n};\n\nconsole.log('start')\nexample();\nconsole.log('end')\n```",
            "translated": {
                "en": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nSince *wes* is an execution environment for synchronous processing, *setTimeout* *setInterval* *setImmediate* *Promise* does not function as asynchronous processing, but it is implemented to support modules that assume *Promise* implementation.\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "zh-CN": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\n由于*wes*是用于同步处理的执行环境，因此*setTimeout* *setInterval* *setImmediate* *Promise*并不能起到异步处理的作用，但它的实现是为了支持假设*Promise*实现的模块。\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "zh-TW": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\n由於*wes*是用於同步處理的執行環境，因此*setTimeout* *setInterval* *setImmediate* *Promise*不起到異步處理的作用，但它的實現是為了支持假設*Promise*實現的模塊。\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "es": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nDado que *wes* es un entorno de ejecución para procesamiento síncrono, *setTimeout* *setInterval* *setImmediate* *Promise* no funciona como procesamiento asíncrono, pero se implementa para admitir módulos que asumen la implementación de *Promise* .\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "de": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nDa *wes* eine Ausführungsumgebung für synchrone Verarbeitung ist, *setTimeout* *setInterval* *setImmediate* *Promise* nicht als asynchrone Verarbeitung, sondern wird implementiert, um Module zu unterstützen, die eine *Promise* -Implementierung voraussetzen.\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "fr": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nÉtant donné que *wes* est un environnement d'exécution pour le traitement synchrone, *setTimeout* *setInterval* *setImmediate* *Promise* ne fonctionne pas comme un traitement asynchrone, mais il est implémenté pour prendre en charge les modules qui supposent l'implémentation de *Promise* .\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "hi": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nचूंकि *wes* सिंक्रोनस प्रोसेसिंग के लिए एक निष्पादन वातावरण है, *setTimeout* *setInterval* *setImmediate* *Promise* एसिंक्रोनस प्रोसेसिंग के रूप में कार्य नहीं करता है, लेकिन यह उन मॉड्यूल का समर्थन करने के लिए कार्यान्वित किया जाता है जो *Promise* कार्यान्वयन को मानते हैं।\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "pt": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nComo *wes* é um ambiente de execução para processamento síncrono, *setTimeout* *setInterval* *setImmediate* *Promise* não funciona como processamento assíncrono, mas é implementado para suportar módulos que assumem a implementação de *Promise* .\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "it": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nPoiché *wes* è un ambiente di esecuzione per l'elaborazione sincrona, *setTimeout* *setInterval* *setImmediate* *Promise* non funziona come elaborazione asincrona, ma è implementato per supportare moduli che presuppongono l'implementazione di *Promise* .\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "ru": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nПоскольку *wes* является средой выполнения для синхронной обработки, *setTimeout* *setInterval* *setImmediate* *Promise* не работает как асинхронная обработка, но реализован для поддержки модулей, предполагающих реализацию *Promise* .\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "ms": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nMemandangkan *wes* ialah persekitaran pelaksanaan untuk pemprosesan segerak, *setTimeout* *setInterval* *setImmediate* *Promise* tidak berfungsi sebagai pemprosesan tak segerak, tetapi ia dilaksanakan untuk menyokong modul yang menganggap pelaksanaan *Promise* .\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "nl": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nAangezien *wes* een uitvoeringsomgeving is voor synchrone verwerking, werkt *setTimeout* *setInterval* *setImmediate* *Promise* niet als asynchrone verwerking, maar wordt het geïmplementeerd om modules te ondersteunen die de implementatie van *Promise* veronderstellen.\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "ar": "## *setTimeout* *setInterval* *setImmediate* *Promise* الفوري\n\nنظرًا لأن *wes* هي بيئة تنفيذ للمعالجة المتزامنة ، فإن *setTimeout* *setInterval* *setImmediate* لا تعمل كعملية غير متزامنة ، ولكن يتم تنفيذها لدعم الوحدات النمطية التي *Promise* *Promise*\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n",
                "bn": "## *setTimeout* *setInterval* *setImmediate* *Promise*\n\nযেহেতু *wes* সিঙ্ক্রোনাস প্রসেসিংয়ের জন্য একটি এক্সিকিউশন এনভায়রনমেন্ট, *setTimeout* *setInterval* *setImmediate* *Promise* অ্যাসিঙ্ক্রোনাস প্রসেসিং হিসাবে কাজ করে না, তবে এটি এমন মডিউলগুলিকে সমর্থন করার জন্য প্রয়োগ করা হয় যা *Promise* বাস্তবায়নকে ধরে নেয়।\n\n     const example = () => { const promise = new Promise((resolve, reject) => { console.log('promise') setTimeout(() => { console.log('setTimeout') resolve('resolved'); }, 2000); }).then((val) => { console.log(val) }); console.log('sub') }; console.log('start') example(); console.log('end')\n"
            }
        },
        "# ビルトインモジュール": {
            "content": "# ビルトインモジュール\n\n*wes* では基本的な処理を簡略・共通化するための *built-in modules* があります。",
            "translated": {
                "en": "# Built-in module\n\n*wes* has *built-in modules* to simplify and standardize basic processing.\n",
                "zh-CN": "# 内置模块\n\n*wes*有*built-in modules*来简化和标准化基本处理。\n",
                "zh-TW": "# 內置模塊\n\n*wes*有*built-in modules*來簡化和標準化基本處理。\n",
                "es": "# Módulo incorporado\n\n*wes* tiene *built-in modules* para simplificar y estandarizar el procesamiento básico.\n",
                "de": "# Eingebautes Modul\n\n*wes* verfügt über *built-in modules* , um die grundlegende Verarbeitung zu vereinfachen und zu standardisieren.\n",
                "fr": "# Module intégré\n\n*wes* a *built-in modules* pour simplifier et standardiser le traitement de base.\n",
                "hi": "# अंतर्निहित मॉड्यूल\n\n*wes* में बुनियादी प्रसंस्करण को सरल और मानकीकृत करने के लिए *built-in modules* हैं।\n",
                "pt": "# Módulo embutido\n\n*wes* possui *built-in modules* para simplificar e padronizar o processamento básico.\n",
                "it": "# Modulo integrato\n\n*wes* dispone *built-in modules* per semplificare e standardizzare l'elaborazione di base.\n",
                "ru": "# Встроенный модуль\n\n*wes* имеет *built-in modules* для упрощения и стандартизации базовой обработки.\n",
                "ms": "# Modul terbina dalam\n\n*wes* mempunyai *built-in modules* untuk memudahkan dan menyeragamkan pemprosesan asas.\n",
                "nl": "# Ingebouwde module\n\n*wes* heeft *built-in modules* om de basisverwerking te vereenvoudigen en te standaardiseren.\n",
                "ar": "# وحدة مدمجة\n\nيحتوي *wes* *built-in modules* لتبسيط وتوحيد المعالجة الأساسية.\n",
                "bn": "# অন্তর্নির্মিত মডিউল\n\nমৌলিক প্রক্রিয়াকরণকে সরল ও মানসম্মত করার জন্য *wes* এর *built-in modules* রয়েছে।\n"
            }
        },
        "## *ansi*": {
            "content": "## *ansi*\n\n`ansi` は *ANSI escape code* で、標準出力の色や効果を変更できます。\n使用するコンソールアプリケーションの種類や設定によって色や効果などは異なる場合があります。\n\n```javascript\nconst { redBright, yellow } = require('ansi')\nconst message = 'File does not exist'\nconsole.log(redBright + 'Error: ' + yellow + message)\n```\n\nまた、`ansi.color()` や `ansi.bgColor()` で独自の色の作成ができます。\n引数は `255, 165, 0` などの *RGB* や `'#FFA500'` などの *color code* を使用します。\n`orange` などの *color name* には対応しておりません。\n\n```javascript\nconst { color } = require('ansi')\nconst orange = color(255, 165, 0)\nconsole.log(orange + 'Hello World')\n```",
            "translated": {
                "en": "## *ansi*\n\n`ansi` is *ANSI escape code* that can change standard output colors and effects. Colors and effects may differ depending on the type and settings of the console application used.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nYou can also create your own colors with `ansi.color()` and `ansi.bgColor()` . Arguments use *RGB* such as `255, 165, 0` and *color code* such as `'#FFA500'` . *color name* such as `orange` are not supported.\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "zh-CN": "## *ansi*\n\n`ansi`是*ANSI escape code* ，可以更改标准输出颜色和效果。颜色和效果可能因使用的控制台应用程序的类型和设置而异。\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\n您还可以使用`ansi.color()`和`ansi.bgColor()`创建自己的颜色。参数使用*RGB* （例如`255, 165, 0` ）和*color code* （例如`'#FFA500'` 。不支持`orange`等*color name* 。\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "zh-TW": "## *ansi*\n\n`ansi`是*ANSI escape code* ，可以更改標準輸出顏色和效果。顏色和效果可能因使用的控制台應用程序的類型和設置而異。\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\n您還可以使用`ansi.color()`和`ansi.bgColor()`創建自己的顏色。參數使用*RGB* （例如`255, 165, 0` ）和*color code* （例如`'#FFA500'` 。不支持`orange`等*color name* 。\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "es": "## *ansi*\n\n`ansi` es un *ANSI escape code* que puede cambiar los colores y efectos de salida estándar. Los colores y los efectos pueden diferir según el tipo y la configuración de la aplicación de consola utilizada.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nTambién puede crear sus propios colores con `ansi.color()` y `ansi.bgColor()` . Los argumentos usan *RGB* como `255, 165, 0` y *color code* como `'#FFA500'` . No se admiten *color name* como `orange` .\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "de": "## *ansi*\n\n`ansi` ist ein *ANSI escape code* , der Standardausgabefarben und -effekte ändern kann. Farben und Effekte können je nach Typ und Einstellungen der verwendeten Konsolenanwendung abweichen.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nSie können auch Ihre eigenen Farben mit `ansi.color()` und `ansi.bgColor()` . Argumente verwenden *RGB* wie `255, 165, 0` und *color code* wie `'#FFA500'` . *color name* wie `orange` werden nicht unterstützt.\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "fr": "## *ansi*\n\n`ansi` est *ANSI escape code* qui peut modifier les couleurs et les effets de sortie standard. Les couleurs et les effets peuvent différer selon le type et les paramètres de l'application console utilisée.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nVous pouvez également créer vos propres couleurs avec `ansi.color()` et `ansi.bgColor()` . Les arguments utilisent *RGB* tels que `255, 165, 0` et *color code* tels que `'#FFA500'` . *color name* tels que `orange` ne sont pas pris en charge.\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "hi": "## *ansi*\n\n`ansi` *ANSI escape code* है जो मानक आउटपुट रंग और प्रभाव बदल सकता है। उपयोग किए गए कंसोल एप्लिकेशन के प्रकार और सेटिंग्स के आधार पर रंग और प्रभाव भिन्न हो सकते हैं।\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nआप `ansi.color()` और `ansi.bgColor()` के साथ अपने खुद के रंग भी बना सकते हैं। तर्क *RGB* जैसे `255, 165, 0` और *color code* जैसे `'#FFA500'` हैं। `orange` जैसे *color name* समर्थित नहीं हैं।\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "pt": "## *ansi*\n\n`ansi` é um *ANSI escape code* que pode alterar as cores e efeitos de saída padrão. As cores e os efeitos podem diferir dependendo do tipo e das configurações do aplicativo de console usado.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nVocê também pode criar suas próprias cores com `ansi.color()` e `ansi.bgColor()` . Os argumentos usam *RGB* como `255, 165, 0` e *color code* como `'#FFA500'` . *color name* como `orange` não são suportados.\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "it": "## *ansi*\n\n`ansi` è un *ANSI escape code* che può modificare i colori e gli effetti dell'output standard. I colori e gli effetti possono variare a seconda del tipo e delle impostazioni dell'applicazione console utilizzata.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nPuoi anche creare i tuoi colori con `ansi.color()` e `ansi.bgColor()` . Gli argomenti utilizzano *RGB* come `255, 165, 0` e *color code* come `'#FFA500'` . I *color name* come l' `orange` non sono supportati.\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "ru": "## *ansi*\n\n`ansi` — это *ANSI escape code* , который может изменять стандартные выходные цвета и эффекты. Цвета и эффекты могут отличаться в зависимости от типа и настроек используемого консольного приложения.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nВы также можете создавать свои собственные цвета с помощью `ansi.color()` и `ansi.bgColor()` . Аргументы используют *RGB* , например `255, 165, 0` и *color code* , например `'#FFA500'` . *color name* , такие как `orange` , не поддерживаются.\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "ms": "## *ansi*\n\n`ansi` ialah *ANSI escape code* yang boleh menukar warna dan kesan output standard. Warna dan kesan mungkin berbeza bergantung pada jenis dan tetapan aplikasi konsol yang digunakan.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nAnda juga boleh mencipta warna anda sendiri dengan `ansi.color()` dan `ansi.bgColor()` . Hujah menggunakan *RGB* seperti `255, 165, 0` dan *color code* seperti `'#FFA500'` . *color name* seperti `orange` tidak disokong.\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "nl": "## *ansi*\n\n`ansi` is *ANSI escape code* die standaarduitvoerkleuren en -effecten kan wijzigen. Kleuren en effecten kunnen verschillen, afhankelijk van het type en de instellingen van de gebruikte consoletoepassing.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nU kunt ook uw eigen kleuren maken met `ansi.color()` en `ansi.bgColor()` . Argumenten gebruiken *RGB* zoals `255, 165, 0` en *color code* zoals `'#FFA500'` . *color name* zoals `orange` worden niet ondersteund.\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "ar": "## *ansi*\n\n`ansi` هو *ANSI escape code* يمكنه تغيير ألوان الإخراج القياسية والتأثيرات. قد تختلف الألوان والتأثيرات وفقًا لنوع وإعدادات تطبيق وحدة التحكم المستخدمة.\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nيمكنك أيضًا إنشاء الألوان الخاصة بك باستخدام `ansi.color()` و `ansi.bgColor()` . تستخدم الوسائط *RGB* مثل `255, 165, 0` *color code* مثل `'#FFA500'` . *color name* مثل `orange` غير مدعومة.\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n",
                "bn": "## *ansi*\n\nansi হল `ansi` *ANSI escape code* যা আদর্শ আউটপুট রং এবং প্রভাব পরিবর্তন করতে পারে। ব্যবহৃত কনসোল অ্যাপ্লিকেশনের ধরন এবং সেটিংসের উপর নির্ভর করে রঙ এবং প্রভাব ভিন্ন হতে পারে।\n\n     const { redBright, yellow } = require('ansi') const message = 'File does not exist' console.log(redBright 'Error: ' yellow message)\n\nএছাড়াও আপনি `ansi.color()` এবং `ansi.bgColor()` ) দিয়ে আপনার নিজস্ব রং তৈরি করতে পারেন। আর্গুমেন্ট *RGB* ব্যবহার করে যেমন `255, 165, 0` এবং *color code* যেমন `'#FFA500'` । `orange` মতো *color name* সমর্থিত নয়।\n\n     const { color } = require('ansi') const orange = color(255, 165, 0) console.log(orange 'Hello World')\n"
            }
        },
        "## *argv*": {
            "content": "## *argv*\n\nコマンドライン引数のを取得します。\n`cscript.exe` のコマンドライン引数は `/` で名前付き引数を宣言しますが、*wes* では `-` および `--` で\n名前付き引数を宣言します。\n*argv.unnamed* および *argv.named* はコマンドライン引数の値の型を *String* *Number* *Boolean* の何れかにキャストします。\n*REP* と一緒にコマンドライン引数を入力します。\n\n```bat\nwes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n```\n\n*REP* で次のスクリプトを実行します。\n\n```javascript\nconst argv = require('argv')\nconsole.log(`argv: %O\nargv.unnamed: %O\nargv.named: %O`,\nargv, argv.unnamed, argv.named)\n```",
            "translated": {
                "en": "## *argv*\n\nGet command line arguments. `cscript.exe` 's command line arguments declare named arguments with `/` , while *wes* declares named arguments with `-` and `--` . *argv.unnamed* and *argv.named* the command line argument value type to either *String* *Number* *Boolean* . Enter command line arguments with *REP* .\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nRun the following script on *REP* .\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "zh-CN": "## *argv*\n\n获取命令行参数。 `cscript.exe`的命令行参数用`/`声明命名参数，而*wes*用`-`和`--`声明命名参数。 *argv.unnamed*和*argv.named*命令行参数值类型转换为*String* *Number* *Boolean* 。使用*REP*输入命令行参数。\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\n在*REP*上运行以下脚本。\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "zh-TW": "## *argv*\n\n獲取命令行參數。 `cscript.exe`的命令行參數用`/`聲明命名參數，而*wes*用`-`和`--`聲明命名參數。 *argv.unnamed*和*argv.named*命令行參數值類型轉換為*String* *Number* *Boolean* 。使用*REP*輸入命令行參數。\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\n在*REP*上運行以下腳本。\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "es": "## *argv*\n\nObtener argumentos de la línea de comandos. Los argumentos de la línea de comandos de `cscript.exe` declaran argumentos con nombre con `/` , mientras que *wes* declara argumentos con nombre con `-` y `--` . *argv.unnamed* y *argv.named* el tipo de valor del argumento de la línea de comandos en *String* *Number* *Boolean* . Introduzca los argumentos de la línea de comandos con *REP* .\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nEjecute el siguiente script en *REP* .\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "de": "## *argv*\n\nBefehlszeilenargumente erhalten. Die Befehlszeilenargumente von `cscript.exe` deklarieren benannte Argumente mit `/` , während *wes* benannte Argumente mit `-` und `--` deklariert . *argv.unnamed* und *argv.named* des Befehlszeilenarguments entweder in *String* *Number* *Boolean* um. Geben Sie Kommandozeilenargumente mit *REP* ein.\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nFühren Sie das folgende Skript auf *REP* aus.\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "fr": "## *argv*\n\nObtenir les arguments de la ligne de commande. Les arguments de ligne de commande de `cscript.exe` déclarent des arguments nommés avec `/` , tandis que *wes* déclare des arguments nommés avec `-` et `--` . *argv.unnamed* et *argv.named* le type de valeur d'argument de ligne de commande en *String* *Number* *Boolean* . Entrez les arguments de la ligne de commande avec *REP* .\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nExécutez le script suivant sur *REP* .\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "hi": "## *argv*\n\nकमांड लाइन तर्क प्राप्त करें। `cscript.exe` की कमांड लाइन तर्क `/` के साथ नामित तर्कों की घोषणा करते हैं, जबकि *wes* `-` और `--` के साथ नामित तर्कों की घोषणा करते हैं। *argv.unnamed* और *argv.named* कमांड लाइन तर्क मान प्रकार को *String* *Number* *Boolean* में डाला। *REP* के साथ कमांड लाइन तर्क दर्ज करें।\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\n*REP* पर निम्न स्क्रिप्ट चलाएँ।\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "pt": "## *argv*\n\nObtenha argumentos de linha de comando. Os argumentos de linha de comando do `cscript.exe` declaram argumentos nomeados com `/` , enquanto *wes* declara argumentos nomeados com `-` e `--` . *argv.unnamed* e *argv.named* o tipo de valor do argumento da linha de comando para *String* *Number* *Boolean* . Insira os argumentos da linha de comando com *REP* .\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nExecute o script a seguir em *REP* .\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "it": "## *argv*\n\nOttieni argomenti da riga di comando. Gli argomenti della riga di comando di `cscript.exe` dichiarano argomenti denominati con `/` , mentre *wes* dichiara argomenti denominati con `-` e `--` . *argv.unnamed* e *argv.named* del tipo di valore dell'argomento della riga di comando su *String* *Number* *Boolean* . Immettere gli argomenti della riga di comando con *REP* .\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nEsegui il seguente script su *REP* .\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "ru": "## *argv*\n\nПолучить аргументы командной строки. Аргументы командной строки `cscript.exe` объявляют именованные аргументы с помощью `/` , а *wes* объявляет именованные аргументы с помощью `-` и `--` . *argv.unnamed* и *argv.named* приводят тип значения аргумента командной строки к типу *String* *Number* *Boolean* . Введите аргументы командной строки с помощью *REP* .\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nЗапустите следующий скрипт на *REP* .\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "ms": "## *argv*\n\nDapatkan hujah baris arahan. Argumen baris arahan `cscript.exe` mengisytiharkan argumen bernama dengan `/` , manakala *wes* mengisytiharkan argumen bernama dengan `-` dan `--` . *argv.unnamed* dan *argv.named* jenis nilai argumen baris arahan kepada sama ada *Number* *String* *Boolean* . Masukkan argumen baris arahan dengan *REP* .\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nJalankan skrip berikut pada *REP* .\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "nl": "## *argv*\n\nKrijg opdrachtregelargumenten. De opdrachtregelargumenten van `cscript.exe` declareren benoemde argumenten met `/` , terwijl *wes* benoemde argumenten declareren met `-` en `--` . *argv.unnamed* en *argv.named* het waardetype van het opdrachtregelargument naar *String* *Number* *Boolean* . Voer opdrachtregelargumenten in met *REP* .\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nVoer het volgende script uit op *REP* .\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "ar": "## *argv*\n\nاحصل على وسيطات سطر الأوامر. تعلن وسيطات سطر الأوامر الخاصة بـ `cscript.exe` عن الوسائط المسماة بـ `/` ، بينما يعلن *wes* عن الوسائط المسماة بـ `-` و `--` . *argv.unnamed* و argv. *argv.named* نوع قيمة وسيطة سطر الأوامر إما إلى *String* *Number* *Boolean* . أدخل وسيطات سطر الأوامر باستخدام *REP* .\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\nقم بتشغيل البرنامج النصي التالي على *REP* .\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n",
                "bn": "## *argv*\n\nকমান্ড লাইন আর্গুমেন্ট পান. `cscript.exe` এর কমান্ড লাইন আর্গুমেন্ট `/` এর সাথে নামযুক্ত আর্গুমেন্ট ঘোষণা করে, যখন *wes* `-` এবং `--` এর সাথে নামযুক্ত আর্গুমেন্ট ঘোষণা করে। *argv.unnamed* এবং *argv.named* কমান্ড লাইন আর্গুমেন্ট ভ্যালু টাইপকে *String* *Number* *Boolean* কাস্ট করে। *REP* এর সাথে কমান্ড লাইন আর্গুমেন্ট লিখুন।\n\n     wes REP aaa -bcd eee --fgh=iii jjj --kln mmm\n\n*REP* তে নিম্নলিখিত স্ক্রিপ্টটি চালান।\n\n     const argv = require('argv') console.log(`argv: %O argv.unnamed: %O argv.named: %O`, argv, argv.unnamed, argv.named)\n"
            }
        },
        "## *pathname*": {
            "content": "## *pathname*\n\nパスの操作をします。\n一般的には `/` および `\\` から開始されるパスはドライブルートからの相対パスを指します。\n例えば `/filename` と `C:/filename` は同じパスになる場合があります。\n`wes` ではセキュリティーの観点から `/` および `\\` で開始されるパスはワーキングディレクトリからの相対パスと解釈されます。\n\n```javascript\nconst path = require('pathname')\nconst file = path.resolve(__dirname, 'index.js')\nconsole.log('file %O', file)\n```",
            "translated": {
                "en": "## *pathname*\n\nManipulate paths. Paths starting with `/` and `\\` are generally relative to the drive root. For example `/filename` and `C:/filename` can be the same path. For security reasons, `wes` interprets paths starting with `/` and `\\` relative to the working directory.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "zh-CN": "## *pathname*\n\n操纵路径。以`/`和`\\`开头的路径通常相对于驱动器根目录。例如`/filename`和`C:/filename`可以是相同的路径。出于安全原因， `wes`解释以`/`和`\\`开头的相对于工作目录的路径。\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "zh-TW": "## *pathname*\n\n操縱路徑。以`/`和`\\`開頭的路徑通常相對於驅動器根目錄。例如`/filename`和`C:/filename`可以是相同的路徑。出於安全原因， `wes`解釋以`/`和`\\`開頭的相對於工作目錄的路徑。\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "es": "## *pathname*\n\nManipular caminos. Las rutas que comienzan con `/` y `\\` son generalmente relativas a la raíz de la unidad. Por ejemplo `/filename` y `C:/filename` pueden ser la misma ruta. Por razones de seguridad, `wes` interpreta las rutas que comienzan con `/` y `\\` relativas al directorio de trabajo.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "de": "## *pathname*\n\nPfade manipulieren. Pfade, die mit `/` und `\\` beginnen, sind im Allgemeinen relativ zum Stammverzeichnis des Laufwerks. Beispielsweise können `/filename` und `C:/filename` derselbe Pfad sein. Aus Sicherheitsgründen interpretiert `wes` Pfade beginnend mit `/` und `\\` relativ zum Arbeitsverzeichnis.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "fr": "## *pathname*\n\nManipulez les chemins. Les chemins commençant par `/` et `\\` sont généralement relatifs à la racine du lecteur. Par exemple `/filename` et `C:/filename` peuvent être le même chemin. Pour des raisons de sécurité, `wes` interprète les chemins commençant par `/` et `\\` par rapport au répertoire de travail.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "hi": "## *pathname*\n\nरास्तों में हेरफेर। `/` और `\\` से शुरू होने वाले पथ आमतौर पर ड्राइव रूट के सापेक्ष होते हैं। उदाहरण के लिए `/filename` और `C:/filename` एक ही पथ हो सकते हैं। सुरक्षा कारणों से, `wes` कार्यशील निर्देशिका के सापेक्ष `/` और `\\` से शुरू होने वाले पथों की व्याख्या करता है।\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "pt": "## *pathname*\n\nManipular caminhos. Os caminhos que começam com `/` e `\\` são geralmente relativos à raiz da unidade. Por exemplo, `/filename` e `C:/filename` podem ser o mesmo caminho. Por motivos de segurança, `wes` interpreta os caminhos que começam com `/` e `\\` relativos ao diretório de trabalho.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "it": "## *pathname*\n\nManipola percorsi. I percorsi che iniziano con `/` e `\\` sono generalmente relativi alla radice dell'unità. Ad esempio `/filename` e `C:/filename` possono essere lo stesso percorso. Per motivi di sicurezza, `wes` interpreta i percorsi che iniziano con `/` e `\\` relativi alla directory di lavoro.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "ru": "## *pathname*\n\nМанипулировать путями. Пути, начинающиеся с `/` и `\\` , обычно относятся к корню диска. Например, `/filename` и `C:/filename` могут быть одним и тем же путем. Из соображений безопасности `wes` интерпретирует пути, начинающиеся с `/` и `\\` , относительно рабочего каталога.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "ms": "## *pathname*\n\nMemanipulasi laluan. Laluan yang bermula dengan `/` dan `\\` biasanya relatif kepada akar pemacu. Contohnya `/filename` dan `C:/filename` boleh menjadi laluan yang sama. Atas sebab keselamatan, `wes` mentafsir laluan bermula dengan `/` dan `\\` relatif kepada direktori kerja.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "nl": "## *pathname*\n\nManipuleer paden. Paden die beginnen met `/` en `\\` zijn over het algemeen relatief ten opzichte van de stationsroot. Bijvoorbeeld `/filename` en `C:/filename` kunnen hetzelfde pad zijn. Om veiligheidsredenen interpreteert `wes` paden die beginnen met `/` en `\\` relatief aan de werkdirectory.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "ar": "## *pathname*\n\nالتلاعب بالمسارات. المسارات التي تبدأ بـ `/` و `\\` بشكل عام مرتبطة بجذر محرك الأقراص. على سبيل المثال `/filename` و `C:/filename` يمكن أن يكونا نفس المسار. لأسباب أمنية ، يفسر `wes` المسارات التي تبدأ بـ `/` و `\\` المتعلقة بدليل العمل.\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n",
                "bn": "## *pathname*\n\nপাথ ম্যানিপুলেট. `/` এবং `\\` দিয়ে শুরু হওয়া পাথগুলি সাধারণত ড্রাইভ রুটের সাথে আপেক্ষিক। উদাহরণস্বরূপ `/filename` এবং `C:/filename` একই পথ হতে পারে। নিরাপত্তার কারণে, wes কার্যকারী ডিরেক্টরির সাথে সম্পর্কিত `/` এবং `\\` দিয়ে শুরু হওয়া `wes` ব্যাখ্যা করে।\n\n     const path = require('pathname') const file = path.resolve(__dirname, 'index.js') console.log('file %O', file)\n"
            }
        },
        "## *filesystem*": {
            "content": "## *filesystem*\n\nファイルの操作やディレクトリの操作をします。\n`readTextFileSync` はファイルのエンコードを自動推測して読み込みます。\n\n```javascript\nconst fs = require('filesystem')\nconst path = require('pathname')\nconst readme = path.resolve(__dirname, 'README.md')\nconst contents = fs.readTextFileSync(readme)\nconsole.log(contents)\n```",
            "translated": {
                "en": "## *filesystem*\n\nManipulate files and directories. `readTextFileSync` automatically guesses the encoding of the file and reads it.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "zh-CN": "## *filesystem*\n\n操作文件和目录。 `readTextFileSync`自动猜测文件的编码并读取它。\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "zh-TW": "## *filesystem*\n\n操作文件和目錄。 `readTextFileSync`自動猜測文件的編碼並讀取它。\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "es": "## *filesystem*\n\nManipular archivos y directorios. `readTextFileSync` adivina automáticamente la codificación del archivo y lo lee.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "de": "## *filesystem*\n\nManipulieren Sie Dateien und Verzeichnisse. `readTextFileSync` errät automatisch die Kodierung der Datei und liest sie.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "fr": "## *filesystem*\n\nManipuler des fichiers et des répertoires. `readTextFileSync` devine automatiquement l'encodage du fichier et le lit.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "hi": "## *filesystem*\n\nफ़ाइलों और निर्देशिकाओं में हेरफेर करें। `readTextFileSync` स्वचालित रूप से फ़ाइल के एन्कोडिंग का अनुमान लगाता है और उसे पढ़ता है।\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "pt": "## *filesystem*\n\nManipular arquivos e diretórios. `readTextFileSync` automaticamente adivinha a codificação do arquivo e o lê.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "it": "## *filesystem*\n\nManipola file e directory. `readTextFileSync` indovina automaticamente la codifica del file e lo legge.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "ru": "## *filesystem*\n\nРабота с файлами и каталогами. `readTextFileSync` автоматически угадывает кодировку файла и читает его.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "ms": "## *filesystem*\n\nMemanipulasi fail dan direktori. `readTextFileSync` meneka secara automatik pengekodan fail dan membacanya.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "nl": "## *filesystem*\n\nManipuleer bestanden en mappen. `readTextFileSync` raadt automatisch de codering van het bestand en leest het.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "ar": "## *filesystem*\n\nمعالجة الملفات والدلائل. يخمن `readTextFileSync` تلقائيًا ترميز الملف ويقرأه.\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n",
                "bn": "## *filesystem*\n\nফাইল এবং ডিরেক্টরি ম্যানিপুলেট. `readTextFileSync` স্বয়ংক্রিয়ভাবে ফাইলের এনকোডিং অনুমান করে এবং এটি পড়ে।\n\n     const fs = require('filesystem') const path = require('pathname') const readme = path.resolve(__dirname, 'README.md') const contents = fs.readTextFileSync(readme) console.log(contents)\n"
            }
        },
        "## *chardet*": {
            "content": "## *chardet*\n\n<https://github.com/runk/node-chardet> の一部の機能を使用しています。\nエンコード固有の文字を増やすことで自動推測の精度を上げられます。",
            "translated": {
                "en": "## *chardet*\n\nI am using some features from <https://github.com/runk/node-chardet> . You can increase the accuracy of auto-guessing by increasing encoding-specific characters.\n",
                "zh-CN": "## *chardet*\n\n我正在使用<https://github.com/runk/node-chardet>的一些功能。您可以通过增加特定于编码的字符来提高自动猜测的准确性。\n",
                "zh-TW": "## *chardet*\n\n我正在使用<https://github.com/runk/node-chardet>的一些功能。您可以通過增加特定於編碼的字符來提高自動猜測的準確性。\n",
                "es": "## *chardet*\n\nEstoy usando algunas funciones de <https://github.com/runk/node-chardet> . Puede aumentar la precisión de las adivinanzas automáticas aumentando los caracteres específicos de la codificación.\n",
                "de": "## *chardet*\n\nIch verwende einige Funktionen von <https://github.com/runk/node-chardet> . Sie können die Genauigkeit der automatischen Schätzung erhöhen, indem Sie die Zahl der kodierungsspezifischen Zeichen erhöhen.\n",
                "fr": "## *chardet*\n\nJ'utilise certaines fonctionnalités de <https://github.com/runk/node-chardet> . Vous pouvez augmenter la précision de l'auto-estimation en augmentant les caractères spécifiques à l'encodage.\n",
                "hi": "## *chardet*\n\nमैं <https://github.com/runk/node-chardet> से कुछ सुविधाओं का उपयोग कर रहा हूं। आप एन्कोडिंग-विशिष्ट वर्णों को बढ़ाकर स्वतः अनुमान लगाने की सटीकता बढ़ा सकते हैं।\n",
                "pt": "## *chardet*\n\nEstou usando alguns recursos de <https://github.com/runk/node-chardet> . Você pode aumentar a precisão da adivinhação automática aumentando os caracteres específicos da codificação.\n",
                "it": "## *chardet*\n\nSto usando alcune funzionalità di <https://github.com/runk/node-chardet> . Puoi aumentare la precisione dell'auto-indovina aumentando i caratteri specifici della codifica.\n",
                "ru": "## *chardet*\n\nЯ использую некоторые функции из <https://github.com/runk/node-chardet> . Вы можете повысить точность автоматического угадывания, увеличив количество символов, специфичных для кодировки.\n",
                "ms": "## *chardet*\n\nSaya menggunakan beberapa ciri dari <https://github.com/runk/node-chardet> . Anda boleh meningkatkan ketepatan auto-teka dengan meningkatkan aksara khusus pengekodan.\n",
                "nl": "## *chardet*\n\nIk gebruik enkele functies van <https://github.com/runk/node-chardet> . U kunt de nauwkeurigheid van automatisch raden vergroten door coderingsspecifieke tekens te vergroten.\n",
                "ar": "## *chardet*\n\nأنا أستخدم بعض الميزات من <https://github.com/runk/node-chardet> . يمكنك زيادة دقة التخمين التلقائي عن طريق زيادة الأحرف الخاصة بالترميز.\n",
                "bn": "## *chardet*\n\nআমি <https://github.com/runk/node-chardet> থেকে কিছু বৈশিষ্ট্য ব্যবহার করছি। আপনি এনকোডিং-নির্দিষ্ট অক্ষর বাড়িয়ে স্বয়ংক্রিয় অনুমান করার সঠিকতা বাড়াতে পারেন।\n"
            }
        },
        "## *JScript*": {
            "content": "## *JScript*\n\nスクリプトエンジンを *Chakra* に変更すると、*JScript* 固有の *Enumerator* などが使用できなくなります。\nビルトインモジュールの *JScript* はそれらを使用可能にします。\nただし、*Enumerator* は *Enumerator object* ではなく *Array* を返します。\n\n```javascript\nconst { Enumerator, ActiveXObject } = require('JScript')\nconst FSO = new ActiveXObject('Scripting.FileSystemObject')\nconst dir = FSO.getFolder(__dirname).Files\nconst files = new Enumerator(dir)\nfiles.forEach(file => console.log(file.Name))\n```\n\n*GetObject* は `WScript.GetObject` の代替として機能します。\n\n```javascript\nconst { GetObject, Enumerator } = require('JScript')\nconst ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\")\nnew Enumerator(ServiceSet).forEach(service => console.log(\n    'Name: %O\\nDescription: %O\\n',\n    service.Name,\n    service.Description\n))\n```",
            "translated": {
                "en": "## *JScript*\n\nIf you change the script engine to *Chakra* , you won't be able to use *JScript* -specific *Enumerator* , etc. The built-in module *JScript* makes them available. However, *Enumerator* returns an *Array* , not an *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* works as an alternative to `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "zh-CN": "## *JScript*\n\n如果您将脚本引擎更改为*Chakra* ，您将无法使用*JScript*特定的*Enumerator*等。内置模块*JScript*使它们可用。但是， *Enumerator*返回一个*Array* ，而不是*Enumerator object* 。\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject*作为`WScript.GetObject`的替代品。\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "zh-TW": "## *JScript*\n\n如果您將腳本引擎更改為*Chakra* ，您將無法使用*JScript*特定的*Enumerator*等。內置模塊*JScript*使它們可用。但是， *Enumerator*返回一個*Array* ，而不是*Enumerator object* 。\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject*作為`WScript.GetObject`的替代品。\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "es": "## *JScript*\n\nSi cambia el motor de secuencias de comandos a *Chakra* , no podrá usar *Enumerator* específicos de *JScript* , etc. El módulo integrado *JScript* los pone a disposición. Sin embargo, *Enumerator* devuelve un *Array* , no un *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* funciona como una alternativa a `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "de": "## *JScript*\n\nWenn Sie die Skript-Engine in *Chakra* ändern, können Sie keine *JScript* -spezifischen *Enumerator* usw. verwenden. Das eingebaute Modul *JScript* stellt sie zur Verfügung. *Enumerator* gibt jedoch ein *Array* zurück, kein *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* funktioniert als Alternative zu `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "fr": "## *JScript*\n\nSi vous changez le moteur de script en *Chakra* , vous ne pourrez pas utiliser les *Enumerator* spécifiques à *JScript* , etc. Le module intégré *JScript* les rend disponibles. Cependant, *Enumerator* renvoie un *Array* , pas un *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* fonctionne comme une alternative à `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "hi": "## *JScript*\n\nयदि आप स्क्रिप्ट इंजन को *Chakra* में बदलते हैं, तो आप *JScript* -विशिष्ट *Enumerator* , आदि का उपयोग नहीं कर पाएंगे। बिल्ट-इन मॉड्यूल *JScript* उन्हें उपलब्ध कराता है। हालांकि, *Enumerator* एक *Array* देता है, न कि *Enumerator object* ।\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* `WScript.GetObject` के विकल्प के रूप में काम करता है।\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "pt": "## *JScript*\n\nSe você alterar o mecanismo de script para *Chakra* , não poderá usar *Enumerator* específicos de *JScript* , etc. O módulo embutido *JScript* os disponibiliza. No entanto, *Enumerator* retorna um *Array* , não um *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* funciona como uma alternativa para `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "it": "## *JScript*\n\nSe modifichi il motore di script in *Chakra* , non sarai in grado di utilizzare *Enumerator* specifici di *JScript* , ecc. Il modulo integrato *JScript* li rende disponibili. Tuttavia, *Enumerator* restituisce un oggetto *Array* , non un *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* funziona come alternativa a `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "ru": "## *JScript*\n\nЕсли вы измените скриптовый движок на *Chakra* , вы не сможете использовать специфичные для *JScript* *Enumerator* и т. д. Встроенный модуль *JScript* делает их доступными. Однако *Enumerator* возвращает *Array* , а не *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* работает как альтернатива `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "ms": "## *JScript*\n\nJika anda menukar enjin skrip kepada *Chakra* , anda tidak akan dapat menggunakan *JScript* -specific *Enumerator* , dsb. Modul terbina dalam *JScript* menjadikannya tersedia. Walau bagaimanapun, *Enumerator* mengembalikan *Array* , bukan *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* berfungsi sebagai alternatif kepada `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "nl": "## *JScript*\n\nAls u de scriptengine wijzigt in *Chakra* , kunt u geen *JScript* -specifieke *Enumerator* , enz. gebruiken. De ingebouwde module *JScript* stelt ze beschikbaar. *Enumerator* retourneert echter een *Array* , geen *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* werkt als een alternatief voor `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "ar": "## *JScript*\n\nإذا قمت بتغيير محرك البرنامج النصي إلى *Chakra* ، فلن تتمكن من استخدام *Enumerator* الخاصة بـ *JScript* ، وما إلى ذلك. وحدة *JScript* المدمجة تجعلها متاحة. ومع ذلك ، يقوم *Enumerator* بإرجاع *Array* ، وليس *Enumerator object* .\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\nيعمل *GetObject* كبديل لـ `WScript.GetObject` .\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n",
                "bn": "## *JScript*\n\nআপনি যদি স্ক্রিপ্ট ইঞ্জিনকে *JScript* পরিবর্তন করেন, তাহলে আপনি *Chakra* নির্দিষ্ট *Enumerator* ইত্যাদি ব্যবহার করতে পারবেন না। অন্তর্নির্মিত মডিউল *JScript* তাদের উপলব্ধ করে তোলে। যাইহোক, *Enumerator* একটি *Array* করে, একটি *Enumerator object* নয়।\n\n     const { Enumerator, ActiveXObject } = require('JScript') const FSO = new ActiveXObject('Scripting.FileSystemObject') const dir = FSO.getFolder(__dirname).Files const files = new Enumerator(dir) files.forEach(file => console.log(file.Name))\n\n*GetObject* `WScript.GetObject` বিকল্প হিসেবে কাজ করে।\n\n     const { GetObject, Enumerator } = require('JScript') const ServiceSet = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").InstancesOf(\"Win32_Service\") new Enumerator(ServiceSet).forEach(service => console.log( 'Name: %O\\nDescription: %O\\n', service.Name, service.Description ))\n"
            }
        },
        "## *VBScript*": {
            "content": "## *VBScript*\n\n*VBScript* は *JScript* にはない機能のいくつかを提供します。\n\n```javascript\nconst { TypeName } = require('VBScript')\nconst FSO = require('Scripting.FileSystemObject')\nconsole.log(TypeName(FSO))\n```",
            "translated": {
                "en": "## *VBScript*\n\n*VBScript* offers some features that *JScript* does not.\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "zh-CN": "## *VBScript*\n\n*VBScript*提供了一些*JScript*没有的功能。\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "zh-TW": "## *VBScript*\n\n*VBScript*提供了一些*JScript*沒有的功能。\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "es": "## *VBScript*\n\n*VBScript* ofrece algunas funciones que *JScript* no ofrece.\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "de": "## *VBScript*\n\n*VBScript* bietet einige Funktionen, die *JScript* nicht bietet.\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "fr": "## *VBScript*\n\n*VBScript* offre certaines fonctionnalités que *JScript* n'offre pas.\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "hi": "## *VBScript*\n\n*VBScript* कुछ सुविधाएं प्रदान करता है जो *JScript* नहीं करता है।\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "pt": "## *VBScript*\n\n*VBScript* oferece alguns recursos que o *JScript* não oferece.\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "it": "## *VBScript*\n\n*VBScript* offre alcune funzionalità che *JScript* non offre.\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "ru": "## *VBScript*\n\n*VBScript* предлагает некоторые функции, которых нет *JScript* .\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "ms": "## *VBScript*\n\n*VBScript* menawarkan beberapa ciri yang tidak dimiliki oleh *JScript* .\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "nl": "## *VBScript*\n\n*VBScript* biedt enkele functies die *JScript* niet biedt.\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "ar": "## *VBScript*\n\nيقدم *VBScript* بعض الميزات التي لا توفرها *JScript* .\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n",
                "bn": "## *VBScript*\n\n*VBScript* কিছু বৈশিষ্ট্য অফার করে যা *JScript* করে না।\n\n     const { TypeName } = require('VBScript') const FSO = require('Scripting.FileSystemObject') console.log(TypeName(FSO))\n"
            }
        },
        "## *httprequest*": {
            "content": "## *httprequest*\n\n*httprequest* は *http request* を発行します。\n\n```javascript\nconst request = require('httprequest')\nconst content = request('GET', 'https://jsonplaceholder.typicode.com/users/1')\nconsole.log('%O', JSON.parse(content))\n```",
            "translated": {
                "en": "## *httprequest*\n\n*httprequest* issues an *http request* .\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "zh-CN": "## *httprequest*\n\n*httprequest*发出一个*http request* 。\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "zh-TW": "## *httprequest*\n\n*httprequest*發出一個*http request* 。\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "es": "## *httprequest*\n\n*httprequest* emite una *http request* .\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "de": "## *httprequest*\n\n*httprequest* gibt eine *http request* aus.\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "fr": "## *httprequest*\n\n*httprequest* émet une *http request* .\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "hi": "## *httprequest*\n\n*httprequest* एक *http request* जारी करता है।\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "pt": "## *httprequest*\n\n*httprequest* emite uma *http request* .\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "it": "## *httprequest*\n\n*httprequest* emette una *http request* .\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "ru": "## *httprequest*\n\n*httprequest* *http request* .\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "ms": "## *httprequest*\n\n*httprequest* mengeluarkan *http request* .\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "nl": "## *httprequest*\n\n*httprequest* geeft een *http request* uit.\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "ar": "## *httprequest*\n\n*httprequest* يصدر *http request* .\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n",
                "bn": "## *httprequest*\n\n*httprequest* একটি *http request* ইস্যু করে।\n\n     const request = require('httprequest') const content = request('GET', 'https://jsonplaceholder.typicode.com/users/1') console.log('%O', JSON.parse(content))\n"
            }
        },
        "## *minitest*": {
            "content": "## *minitest*\n\n*minitest* は簡易的なテストを記述できます。\nversion `0.10.71` から基本コンセプトに立ち返って、アサーションの種類を３種類に減らしました。\n\n### 使い方\n\n`describe` でグループに分け、`it` でテストを記述し、`assert` で検証します。\n`pass` は `it` の出現回数と合格数の配列になります。\n\n```javascript\nconst { describe, it, assert, pass } = require('minitest')\ndescribe('minitest', () => {\n    describe('add', () => {\n        const add = (a, b) => a + b\n        it('2 plus 3 is 5', () => {\n            assert.equal(5, add(2, 3))\n        })\n        it('0 plus 0 is 0', () => {\n            assert(0 === add(0, 0))\n        })\n        it('\"4\" plus \"5\" is 9', () => {\n            assert.equal(9, add(\"4\", \"5\"))\n        })\n        it('NaN plus 3 is NaN', () => {\n            assert.equal(NaN, add(NaN, 3))\n        })\n    })\n    describe('sub', () => {\n        it('5 minus 4 is 1', () => {\n            const sub = (a, b) => a - b\n            assert.equal(1, sub(5, 4))\n        })\n    })\n})\nconsole.log('tests: %O passed: %O, failed: %O', pass[0], pass[1], pass[0] - pass[1])\n```\n\n### assertion\n\n#### `assert(value, message)` `assert.ok(value, message)`\n\n厳密等価演算子 `===` で `true` と比較します。`value` が関数の場合は関数を実行した結果を評価します。\n\n| Param     | Type                  | Description     |\n| :-------- | :-------------------- | :-------------- |\n| `value`   | `{Function\\|Boolean}` | 真偽値もしくは真偽値を返す関数 |\n| `message` | `{String}`            | 失敗した場合のメッセージ    |\n\n#### `assert.equal(expected, actual)`\n\nオブジェクトを参照先ではなく、メンバーが同値かどうかで比較します。\\\n通常の厳密等価演算子では `true` にらない `NaN === NaN` `function (){} === function (){}` `/RegExp/g === /RegExp/g` や\n`{one: {two: 2}} === {one: {two: 2}}` `[1,2,3] === [1,2,3]` なども成立します。\\\nクラス（オブジェクト）同士の比較の場合は同じコンストラクタもしくは `actual` が `expected` のスーパークラスである必要があります。\n\n| Param      | Type    | Description |\n| :--------- | :------ | :---------- |\n| `expected` | `{Any}` | 期待する値       |\n| `actual`   | `{Any}` | 実際の値        |\n\n#### `assert.throws(value, expected, message)`\n\n正しくエラーが投げられているかを検証します。\\\nエラーが正しいかどうかは、期待されたエラーの *constructor* なのか、もしくは *message* が同値、 正規表現が *stack* を評価に合格するかどうかで判断されます。\n\n| Param      | Type                      | Description                                               |\n| :--------- | :------------------------ | :-------------------------------------------------------- |\n| `value`    | `{Error}`                 | エラー                                                       |\n| `expected` | `{Error\\|String\\|RegExp}` | 期待するエラーの *constructor* か *message* もしくは *stack* を評価する正規表現 |\n| `message`  | `{String}`                | 失敗した場合のメッセージ                                              |",
            "translated": {
                "en": "undefined\n",
                "zh-CN": "undefined\n",
                "zh-TW": "undefined\n",
                "es": "undefined\n",
                "de": "undefined\n",
                "fr": "undefined\n",
                "hi": "undefined\n",
                "pt": "undefined\n",
                "it": "undefined\n",
                "ru": "undefined\n",
                "ms": "undefined\n",
                "nl": "undefined\n",
                "ar": "undefined\n",
                "bn": "undefined\n"
            }
        },
        "## *pipe*": {
            "content": "## *pipe*\n\n*pipe* はパイプ処理を簡素化します。\n\n### 使い方\n\n```javascript\nconst pipe = require('pipe')\nfunction add (a, b) {\n    return b + a\n}\nfunction sub (a, b) {\n    return b - a\n}\nfunction div (a, b) {\n    return a / b\n}\nconst add5 = add.bind(null, 5)\nconst sub3 = sub.bind(null, 3)\npipe()\n  .use(add5)\n  .use(sub3)\n  .use(div, 4)\n  .process(10, (err, res) => console.log('res: %O', res))\n```",
            "translated": {
                "en": "## *pipe*\n\n*pipe* simplifies piping.\n\n### Usage\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "zh-CN": "## *pipe*\n\n*pipe*简化了管道。\n\n### 用法\n\n    const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "zh-TW": "## *pipe*\n\n*pipe*簡化了管道。\n\n### 用法\n\n    const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "es": "## *pipe*\n\n*pipe* simplifica la instalación de tuberías.\n\n### Uso\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "de": "## *pipe*\n\n*pipe* vereinfacht die Verrohrung.\n\n### Verwendungszweck\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "fr": "## *pipe*\n\n*pipe* simplifie la tuyauterie.\n\n### Usage\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "hi": "## *pipe*\n\n*pipe* पाइपिंग को सरल करता है।\n\n### प्रयोग\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "pt": "## *pipe*\n\n*pipe* simplifica a tubulação.\n\n### Uso\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "it": "## *pipe*\n\n*pipe* semplifica le tubazioni.\n\n### Utilizzo\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "ru": "## *pipe*\n\n*pipe* упрощает трубопровод.\n\n### Применение\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "ms": "## *pipe*\n\n*pipe* memudahkan paip.\n\n### Penggunaan\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "nl": "## *pipe*\n\n*pipe* vereenvoudigt pijpen.\n\n### Gebruik\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "ar": "## *pipe*\n\nيبسط *pipe* الأنابيب.\n\n### إستعمال\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n",
                "bn": "## *pipe*\n\n*pipe* পাইপিংকে সহজ করে।\n\n### ব্যবহার\n\n     const pipe = require('pipe') function add (a, b) { return ba } function sub (a, b) { return b - a } function div (a, b) { return a / b } const add5 = add.bind(null, 5) const sub3 = sub.bind(null, 3) pipe() .use(add5) .use(sub3) .use(div, 4) .process(10, (err, res) => console.log('res: %O', res))\n"
            }
        },
        "## *typecheck*": {
            "content": "## *typecheck*\n\nスクリプトの型の判定をします。\n\n### 使い方\n\n```javascript\nconst { isString, isNumber, isBoolean, isObject } = require('typecheck')\nconst log = require('log')\nlog(() => isString(\"ECMAScript\"))\nlog(() => isNumber(43.5))\nlog(() => isBoolean(false))\nlog(() => isObject(function(){}))\n```",
            "translated": {
                "en": "## *typecheck*\n\nDetermine the script type.\n\n### Usage\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "zh-CN": "## *typecheck*\n\n确定脚本类型。\n\n### 用法\n\n    const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "zh-TW": "## *typecheck*\n\n確定腳本類型。\n\n### 用法\n\n    const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "es": "## *typecheck*\n\nDeterminar el tipo de guión.\n\n### Uso\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "de": "## *typecheck*\n\nBestimmen Sie den Skripttyp.\n\n### Verwendungszweck\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "fr": "## *typecheck*\n\nDéterminez le type de script.\n\n### Usage\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "hi": "## *typecheck*\n\nस्क्रिप्ट प्रकार निर्धारित करें।\n\n### प्रयोग\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "pt": "## *typecheck*\n\nDetermine o tipo de script.\n\n### Uso\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "it": "## *typecheck*\n\nDetermina il tipo di script.\n\n### Utilizzo\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "ru": "## *typecheck*\n\nОпределите тип сценария.\n\n### Применение\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "ms": "## *typecheck*\n\nTentukan jenis skrip.\n\n### Penggunaan\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "nl": "## *typecheck*\n\nBepaal het scripttype.\n\n### Gebruik\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "ar": "## *typecheck*\n\nحدد نوع البرنامج النصي.\n\n### إستعمال\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n",
                "bn": "## *typecheck*\n\nস্ক্রিপ্টের ধরন নির্ধারণ করুন।\n\n### ব্যবহার\n\n     const { isString, isNumber, isBoolean, isObject } = require('typecheck') const log = require('log') log(() => isString(\"ECMAScript\")) log(() => isNumber(43.5)) log(() => isBoolean(false)) log(() => isObject(function(){}))\n"
            }
        },
        "## *animate*": {
            "content": "## *animate*\n\n*animate* はコンソールの表示をアニメーションさせる手助けをします。\n\n### 使い方\n\n処理に時間が掛かる場合は進捗度合をコンソールにアニメーションとして表示させた方が親切です。\n\n```javascript\nconst Animate = require('animate')\nconst animate = new Animate\nconst size = 23\nlet counter = 0\n\nconst progress = Animate.genProgressIndicator([\n    '|----------|----------|',\n    '|*---------|----------|',\n    '|**--------|----------|',\n    '|***-------|----------|',\n    '|****------|----------|',\n    '|*****-----|----------|',\n    '|******----|----------|',\n    '|*******---|----------|',\n    '|********--|----------|',\n    '|*********-|----------|',\n    '|**********|----------|',\n    '|**********|*---------|',\n    '|**********|**--------|',\n    '|**********|***-------|',\n    '|**********|****------|',\n    '|**********|*****-----|',\n    '|**********|******----|',\n    '|**********|*******---|',\n    '|**********|********--|',\n    '|**********|*********-|',\n    '|**********|**********|',\n])\n\nconst indigator = Animate.genProgressIndicator(['   ', '.  ', '.. ', '...'])\n\nanimate.register(() => {\n    let prog = counter / size\n    if (prog >= 1) {\n        prog = 1\n        animate.stop()\n    }\n\n    animate.view = console.format(\n        '%S %S %S',\n        progress(Math.ceil(prog * 20)),\n        ('  ' + Math.ceil(prog * 100) + '%').slice(-4),\n        prog < 1 ? 'loading' + indigator(counter) : 'finished!'\n    )\n    counter++\n}, 100, Number.MAX_VALUE)\nanimate.run()\n```\n\n### `constructor(complete)`\n\n全てのキューが完了するか、`stop()` が実行された場合に`complete` 関数を実行します。\n\n#### `static genProgressIndicator(animation)`\n\n循環するアニメーションを表示する関数を生成します。\n\n#### `register(callback, interval, conditional)`\n\n処理を登録します。処理は複数登録でき、平行処理します。\n`callback` の中で、アニメーションのストップの指示や、表示するビューの書き込みをします。\n`interval` は処理間隔を指定します。\n`conditional` は関数の場合は `conditional(count, queue)` を実行して結果が真の場合は次も継続して実行します。\n`conditional` は数値の場合は `decrement(count)` を実行して結果が正の数値の場合は次も継続して実行します。\n`conditional` が未定義の場合は1回のみ実行します。\n注意するのは関数を指定した場合の `count` は増加するのに対し、数値を指定したの場合の `count` は減少します。\n\n#### `stop()`\n\n*animate* を中断します。\n\n#### `cancel(queue)`\n\n特定キューの処理を中断します。\n\n#### `run()`\n\nアニメーションを開始します。\n\n#### `view`\n\nコンソールに出力される文字を指定します。\n一定間隔毎に文字を切り替えます。\n`view` には *Arrary* と *String* のどちらかを代入します。\n単一のアニメーションを更新する場合は *String* が便利で、\n複数の行を個別にアニメーションする場合は *Array* が便利です。\n\n```javascript\nconst Animate = require('/lib/animate')\nconst animate = new Animate(\n    () => console.log('All Finished!!')\n)\n\nconst progress = Animate.genProgressIndicator([\n    '|----------|----------|',\n    '|*---------|----------|',\n    '|**--------|----------|',\n    '|***-------|----------|',\n    '|****------|----------|',\n    '|*****-----|----------|',\n    '|******----|----------|',\n    '|*******---|----------|',\n    '|********--|----------|',\n    '|*********-|----------|',\n    '|**********|----------|',\n    '|**********|*---------|',\n    '|**********|**--------|',\n    '|**********|***-------|',\n    '|**********|****------|',\n    '|**********|*****-----|',\n    '|**********|******----|',\n    '|**********|*******---|',\n    '|**********|********--|',\n    '|**********|*********-|',\n    '|**********|**********|',\n])\n\nconst indigator = Animate.genProgressIndicator(['   ', '.  ', '.. ', '...'])\n\nconst state = {\n    one: null,\n    two: null,\n    three: null\n}\n\nfunction upload(name, size, row) {\n    let counter = 0\n    return () => {\n        let prog = counter / size\n        if (prog >= 1) {\n            prog = 1\n            animate.cancel(state[name])\n        }\n\n        animate.view[row] = console.format(\n            '%S %S %S',\n            progress(Math.ceil(prog * 20)),\n            ('  ' + Math.ceil(prog * 100) + '%').slice(-4),\n            prog < 1 ? name + ' loading' + indigator(counter) : name + ' finished! '\n        )\n        counter++\n    }\n}\n\nstate.one = animate.register(upload('one', 63, 0), 50, Number.MAX_VALUE)\nstate.two = animate.register(upload('two', 49, 1), 60, Number.MAX_VALUE)\nstate.three = animate.register(upload('three', 109, 2), 40, Number.MAX_VALUE)\nanimate.run()\n```",
            "translated": {
                "en": "undefined\n",
                "zh-CN": "undefined\n",
                "zh-TW": "undefined\n",
                "es": "undefined\n",
                "de": "undefined\n",
                "fr": "undefined\n",
                "hi": "undefined\n",
                "pt": "undefined\n",
                "it": "undefined\n",
                "ru": "undefined\n",
                "ms": "undefined\n",
                "nl": "undefined\n",
                "ar": "undefined\n",
                "bn": "undefined\n"
            }
        },
        "## *getMember*": {
            "content": "## *getMember*\n\n*ProgID* から *COM Object* のメンバーの種類と説明を取得します。\n\n### 使い方\n\n```javascript\nconst getMember = require('getMember')\nconst FileSystemObject = 'Scripting.FileSystemObject'\nconsole.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n```",
            "translated": {
                "en": "## *getMember*\n\nGet member type and description of *COM Object* from *ProgID* .\n\n### Usage\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "zh-CN": "## *getMember*\n\n从*ProgID*获取*COM Object*的成员类型和描述。\n\n### 用法\n\n    const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "zh-TW": "## *getMember*\n\n從*ProgID*獲取*COM Object*的成員類型和描述。\n\n### 用法\n\n    const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "es": "## *getMember*\n\nObtenga el tipo de miembro y la descripción del *COM Object* de *ProgID* .\n\n### Uso\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "de": "## *getMember*\n\nRufen Sie den Mitgliedstyp und die Beschreibung des *COM Object* von *ProgID* ab.\n\n### Verwendungszweck\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "fr": "## *getMember*\n\nObtenez le type de membre et la description de *COM Object* à partir de *ProgID* .\n\n### Usage\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "hi": "## *getMember*\n\n*ProgID* से सदस्य प्रकार और *COM Object* का विवरण प्राप्त करें।\n\n### प्रयोग\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "pt": "## *getMember*\n\nObtenha o tipo de membro e a descrição do *COM Object* do *ProgID* .\n\n### Uso\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "it": "## *getMember*\n\nOttieni il tipo di membro e la descrizione *COM Object* da *ProgID* .\n\n### Utilizzo\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "ru": "## *getMember*\n\nПолучите тип члена и описание *COM Object* из *ProgID* .\n\n### Применение\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "ms": "## *getMember*\n\nDapatkan jenis ahli dan perihalan *COM Object* daripada *ProgID* .\n\n### Penggunaan\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "nl": "## *getMember*\n\nHaal het lidtype en de beschrijving van het *COM Object* op van *ProgID* .\n\n### Gebruik\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "ar": "## *getMember*\n\nالحصول على نوع العضو ووصف *COM Object* من *ProgID* .\n\n### إستعمال\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n",
                "bn": "## *getMember*\n\n*ProgID* থেকে *COM Object* সদস্যের ধরন এবং বিবরণ পান।\n\n### ব্যবহার\n\n     const getMember = require('getMember') const FileSystemObject = 'Scripting.FileSystemObject' console.log('require(\"%S\") // => %O', FileSystemObject, getMember(FileSystemObject))\n"
            }
        },
        "## *zip*": {
            "content": "## *zip*\n\nファイルやフォルダの圧縮と圧縮ファイルの解凍をします。\n内部で *PowerShell* 呼び出して処理をしています。\n\n### 使い方\n\n```javascript\nconst {zip, unzip} = require('zip')\nconsole.log(zip('docs\\\\*', 'dox.zip'))\nconsole.log(unzip('dox.zip'))\n```\n\n`zip(path, destinationPath)` の `path` にはワイルドカード `*` が記述できます。\n*CLI (Command Line Interface)* と *module* の両方で使用できます。\n\n```bat\nwes zip docs\\* dox.zip\nwes zip -p dox.zip\n```\n\n`path` に拡張子 `.zip` があれば `unzip()` を処理し、拡張子 `.zip` の記述がない。もしくは拡張子 `.zip` があってもワイルドカード `*` の記述があれば `zip()` の処理を行います。\n\n| unnamed | Description          |\n| ------- | -------------------- |\n| `1`     | `path` 入力するフォルダやファイル |\n| `2`     | `dest` 出力するフォルダファイル  |\n\n| named    | short named | Description          |\n| -------- | ----------- | -------------------- |\n| `--path` | `-p`        | `path` 入力するフォルダやファイル |\n| `--dest` | `-d`        | `dest` 出力するフォルダファイル  |",
            "translated": {
                "en": "## *zip*\n\nCompresses files and folders and decompresses compressed files. Internally, *PowerShell* is called and processed.\n\n### Usage\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nA wildcard `*` can be written in the `path` of `zip(path, destinationPath)` . It can be used in both *CLI (Command Line Interface)* and *module* .\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nIf the `path` has the extension `.zip` , `unzip()` is processed, and there is no description of the extension `.zip` . Alternatively, even if there is an extension `.zip` , if there is a wildcard `*` description, `zip()` will be processed.\n\n| unnamed | Description                  |\n| ------- | ---------------------------- |\n| `1`     | `path` or file to enter      |\n| `2`     | folder file to output `dest` |\n\n| named    | short named | Description                  |\n| -------- | ----------- | ---------------------------- |\n| `--path` | `-p`        | `path` or file to enter      |\n| `--dest` | `-d`        | folder file to output `dest` |\n",
                "zh-CN": "## *zip*\n\n压缩文件和文件夹并解压缩压缩文件。在内部， *PowerShell*被调用和处理。\n\n### 用法\n\n    const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\n通配符`*`可以写在`zip(path, destinationPath)` `path`路径中。它可以在*CLI (Command Line Interface)*和*module*中使用。\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\n如果`path`具有扩展名`.zip` ，则处理`unzip()` ，并且没有扩展名`.zip`的描述。或者，即使有扩展名`.zip` ，如果有通配符`*`描述，也会处理`zip()` 。\n\n| 未命名 | 描述               |\n| --- | ---------------- |\n| `1` | `path`要输入的文件夹或文件 |\n| `2` | 文件夹文件输出`dest`    |\n\n| 命名为      | 简称   | 描述               |\n| -------- | ---- | ---------------- |\n| `--path` | `-p` | `path`要输入的文件夹或文件 |\n| `--dest` | `-d` | 文件夹文件输出`dest`    |\n",
                "zh-TW": "## *zip*\n\n壓縮文件和文件夾並解壓縮壓縮文件。在內部， *PowerShell*被調用和處理。\n\n### 用法\n\n    const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\n通配符`*`可以寫在`zip(path, destinationPath)` `path`路徑中。它可以在*CLI (Command Line Interface)*和*module*中使用。\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\n如果`path`具有擴展名`.zip` ，則處理`unzip()` ，並且沒有擴展名`.zip`的描述。或者，即使有擴展名`.zip` ，如果有通配符`*`描述，也會處理`zip()` 。\n\n| 未命名 | 描述               |\n| --- | ---------------- |\n| `1` | `path`要輸入的文件夾或文件 |\n| `2` | 文件夾文件輸出`dest`    |\n\n| 命名為      | 簡稱   | 描述               |\n| -------- | ---- | ---------------- |\n| `--path` | `-p` | `path`要輸入的文件夾或文件 |\n| `--dest` | `-d` | 文件夾文件輸出`dest`    |\n",
                "es": "## *zip*\n\nComprime archivos y carpetas y descomprime archivos comprimidos. Internamente, se llama y procesa *PowerShell* .\n\n### Uso\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nSe puede escribir un comodín `*` en la `path` de `zip(path, destinationPath)` . Se puede utilizar tanto en *CLI (Command Line Interface)* como en *module* .\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nSi la `path` tiene la extensión `.zip` , se procesa `unzip()` y no hay una descripción de la extensión `.zip` . Alternativamente, incluso si hay una extensión `.zip` , si hay una descripción comodín `*` , se procesará `zip()` .\n\n| sin nombre | Descripción                           |\n| ---------- | ------------------------------------- |\n| `1`        | `path` o archivo a ingresar           |\n| `2`        | archivo de carpeta a `dest` de salida |\n\n| nombrada | nombre corto | Descripción                           |\n| -------- | ------------ | ------------------------------------- |\n| `--path` | `-p`         | `path` o archivo a ingresar           |\n| `--dest` | `-d`         | archivo de carpeta a `dest` de salida |\n",
                "de": "## *zip*\n\nKomprimiert Dateien und Ordner und dekomprimiert komprimierte Dateien. Intern wird *PowerShell* aufgerufen und verarbeitet.\n\n### Verwendungszweck\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nIn den `path` von `zip(path, destinationPath)` kann ein Platzhalter `*` geschrieben werden. Es kann sowohl in *CLI (Command Line Interface)* als auch in *module* verwendet werden.\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nWenn der `path` die Erweiterung `.zip` hat, wird `unzip()` verarbeitet und es gibt keine Beschreibung der Erweiterung `.zip` . Alternativ, auch wenn es eine Erweiterung `.zip` gibt, wird `zip()` verarbeitet, wenn eine Platzhalter `*` Beschreibung vorhanden ist.\n\n| unbenannt | Beschreibung                                  |\n| --------- | --------------------------------------------- |\n| `1`       | `path` oder Datei, die eingegeben werden soll |\n| `2`       | Ordner Datei zum `dest`                       |\n\n| genannt  | kurz benannt | Beschreibung                                  |\n| -------- | ------------ | --------------------------------------------- |\n| `--path` | `-p`         | `path` oder Datei, die eingegeben werden soll |\n| `--dest` | `-d`         | Ordner Datei zum `dest`                       |\n",
                "fr": "## *zip*\n\nCompresse les fichiers et les dossiers et décompresse les fichiers compressés. En interne, *PowerShell* est appelé et traité.\n\n### Usage\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nUn caractère générique `*` peut être écrit dans le `path` de `zip(path, destinationPath)` . Il peut être utilisé à la fois dans *CLI (Command Line Interface)* et dans les *module* .\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nSi le `path` a l'extension `.zip` , `unzip()` est traité et il n'y a pas de description de l'extension `.zip` . Alternativement, même s'il y a une extension `.zip` , s'il y a une description générique `*` , `zip()` sera traité.\n\n| anonyme | La description                              |\n| ------- | ------------------------------------------- |\n| `1`     | `path` ou fichier à entrer                  |\n| `2`     | fichier de dossier vers la `dest` de sortie |\n\n| nommé    | nommé court | La description                              |\n| -------- | ----------- | ------------------------------------------- |\n| `--path` | `-p`        | `path` ou fichier à entrer                  |\n| `--dest` | `-d`        | fichier de dossier vers la `dest` de sortie |\n",
                "hi": "## *zip*\n\nफ़ाइलों और फ़ोल्डरों को संपीड़ित करता है और संपीड़ित फ़ाइलों को डीकंप्रेस करता है। आंतरिक रूप से, *PowerShell* को कॉल और संसाधित किया जाता है।\n\n### प्रयोग\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nएक वाइल्डकार्ड `*` को `zip(path, destinationPath)` के `path` में लिखा जा सकता है। इसका उपयोग *CLI (Command Line Interface)* और *module* दोनों में किया जा सकता है।\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nयदि `path` में एक्सटेंशन `.zip` है, तो `unzip()` संसाधित हो गया है, और एक्सटेंशन `.zip` का कोई विवरण नहीं है। वैकल्पिक रूप से, भले ही कोई एक्सटेंशन `.zip` हो, यदि कोई वाइल्डकार्ड `*` विवरण है, तो `zip()` संसाधित किया जाएगा।\n\n| अज्ञात | विवरण                              |\n| ------ | ---------------------------------- |\n| `1`    | `path` या दर्ज करने के लिए फ़ाइल   |\n| `2`    | आउटपुट के लिए फ़ोल्डर फ़ाइल `dest` |\n\n| नामित    | संक्षिप्त नाम | विवरण                              |\n| -------- | ------------- | ---------------------------------- |\n| `--path` | `-p`          | `path` या दर्ज करने के लिए फ़ाइल   |\n| `--dest` | `-d`          | आउटपुट के लिए फ़ोल्डर फ़ाइल `dest` |\n",
                "pt": "## *zip*\n\nCompacta arquivos e pastas e descompacta arquivos compactados. Internamente, o *PowerShell* é chamado e processado.\n\n### Uso\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nUm curinga `*` pode ser escrito no `path` de `zip(path, destinationPath)` . Pode ser usado tanto em *CLI (Command Line Interface)* quanto em *module* .\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nSe o `path` tem a extensão `.zip` , `unzip()` é processado e não há descrição da extensão `.zip` . Alternativamente, mesmo se houver uma extensão `.zip` , se houver uma descrição curinga `*` , `zip()` será processado.\n\n| sem nome | Descrição                          |\n| -------- | ---------------------------------- |\n| `1`      | `path` ou arquivo para inserir     |\n| `2`      | arquivo de pasta para saída `dest` |\n\n| nomeado  | nome curto | Descrição                          |\n| -------- | ---------- | ---------------------------------- |\n| `--path` | `-p`       | `path` ou arquivo para inserir     |\n| `--dest` | `-d`       | arquivo de pasta para saída `dest` |\n",
                "it": "## *zip*\n\nComprime file e cartelle e decomprime i file compressi. Internamente, *PowerShell* viene chiamato ed elaborato.\n\n### Utilizzo\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nUn carattere jolly `*` può essere scritto nel `path` di `zip(path, destinationPath)` . Può essere utilizzato sia in *CLI (Command Line Interface)* che *module* .\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nSe il `path` ha l'estensione `.zip` , `unzip()` viene elaborato e non c'è una descrizione dell'estensione `.zip` . In alternativa, anche se è presente un'estensione `.zip` , se è presente una descrizione con carattere jolly `*` , verrà elaborato `zip()` .\n\n| senza nome | Descrizione                            |\n| ---------- | -------------------------------------- |\n| `1`        | `path` o file da inserire              |\n| `2`        | cartella di output per l'output `dest` |\n\n| di nome  | nome breve | Descrizione                            |\n| -------- | ---------- | -------------------------------------- |\n| `--path` | `-p`       | `path` o file da inserire              |\n| `--dest` | `-d`       | cartella di output per l'output `dest` |\n",
                "ru": "## *zip*\n\nСжимает файлы и папки и распаковывает сжатые файлы. Внутри *PowerShell* вызывается и обрабатывается.\n\n### Применение\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nПодстановочный знак `*` может быть записан в `path` `zip(path, destinationPath)` . Его можно использовать как в *CLI (Command Line Interface)* , так и в *module* .\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nЕсли `path` имеет расширение `.zip` , обрабатывается функция `unzip()` , а описание расширения `.zip` отсутствует. В качестве альтернативы, даже если есть расширение `.zip` , если есть описание с подстановочным знаком `*` , `zip()` будет обработан.\n\n| безымянный | Описание                  |\n| ---------- | ------------------------- |\n| `1`        | `path` или файл для входа |\n| `2`        | файл папки для `dest`     |\n\n| названный | короткое имя | Описание                  |\n| --------- | ------------ | ------------------------- |\n| `--path`  | `-p`         | `path` или файл для входа |\n| `--dest`  | `-d`         | файл папки для `dest`     |\n",
                "ms": "## *zip*\n\nMemampatkan fail dan folder dan menyahmampat fail yang dimampatkan. Secara dalaman, *PowerShell* dipanggil dan diproses.\n\n### Penggunaan\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nKad bebas `*` boleh ditulis dalam `path` `zip(path, destinationPath)` . Ia boleh digunakan dalam kedua-dua *CLI (Command Line Interface)* dan *module* .\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nJika `path` mempunyai sambungan `.zip` , `unzip()` diproses dan tiada perihalan sambungan `.zip` . Sebagai alternatif, walaupun terdapat sambungan `.zip` , jika terdapat kad bebas `*` penerangan, `zip()` akan diproses.\n\n| tidak dinamakan | Penerangan                        |\n| --------------- | --------------------------------- |\n| `1`             | `path` atau fail untuk dimasukkan |\n| `2`             | fail folder ke output `dest`      |\n\n| bernama  | pendek bernama | Penerangan                        |\n| -------- | -------------- | --------------------------------- |\n| `--path` | `-p`           | `path` atau fail untuk dimasukkan |\n| `--dest` | `-d`           | fail folder ke output `dest`      |\n",
                "nl": "## *zip*\n\nComprimeert bestanden en mappen en decomprimeert gecomprimeerde bestanden. Intern wordt *PowerShell* aangeroepen en verwerkt.\n\n### Gebruik\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nEen wildcard `*` kan worden geschreven in het `path` van `zip(path, destinationPath)` . Het kan worden gebruikt in zowel *CLI (Command Line Interface)* als *module* .\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nAls het `path` de extensie `.zip` heeft, wordt `unzip()` verwerkt en is er geen beschrijving van de extensie `.zip` . Als alternatief, zelfs als er een extensie `.zip` is, als er een wildcard `*` beschrijving is, wordt `zip()` verwerkt.\n\n| naamloos | Beschrijving                      |\n| -------- | --------------------------------- |\n| `1`      | `path` of bestand om in te voeren |\n| `2`      | mapbestand naar `dest`            |\n\n| genaamd  | korte naam | Beschrijving                      |\n| -------- | ---------- | --------------------------------- |\n| `--path` | `-p`       | `path` of bestand om in te voeren |\n| `--dest` | `-d`       | mapbestand naar `dest`            |\n",
                "ar": "## *zip*\n\nيضغط الملفات والمجلدات ويفك ضغط الملفات المضغوطة. داخليًا ، يتم استدعاء *PowerShell* ومعالجته.\n\n### إستعمال\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nيمكن كتابة حرف بدل `*` في `path` `zip(path, destinationPath)` . يمكن استخدامه في كل من *CLI (Command Line Interface)* *module* .\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nإذا كان `path` يحتوي على الامتداد `.zip` ، تتم معالجة `unzip()` ، ولا يوجد وصف `.zip` . بدلاً من ذلك ، حتى إذا كان هناك امتداد `.zip` ، إذا كان هناك وصف بدل `*` ، فستتم معالجة `zip()` .\n\n| غير مسمى | وصف                    |\n| -------- | ---------------------- |\n| `1`      | `path` أو ملف للدخول   |\n| `2`      | ملف مجلد لإخراج `dest` |\n\n| اسم الشيئ | اسم قصير | وصف                    |\n| --------- | -------- | ---------------------- |\n| `--path`  | `-p`     | `path` أو ملف للدخول   |\n| `--dest`  | `-d`     | ملف مجلد لإخراج `dest` |\n",
                "bn": "## *zip*\n\nফাইল এবং ফোল্ডারগুলিকে সংকুচিত করে এবং সংকুচিত ফাইলগুলিকে ডিকম্প্রেস করে। অভ্যন্তরীণভাবে, *PowerShell* বলা হয় এবং প্রক্রিয়া করা হয়।\n\n### ব্যবহার\n\n     const {zip, unzip} = require('zip') console.log(zip('docs\\\\*', 'dox.zip')) console.log(unzip('dox.zip'))\n\nএকটি ওয়াইল্ডকার্ড `*` `zip(path, destinationPath)` এর `path` লেখা যেতে পারে। এটি *CLI (Command Line Interface)* এবং *module* উভয় ক্ষেত্রেই ব্যবহার করা যেতে পারে।\n\n     wes zip docs\\* dox.zip wes zip -p dox.zip\n\nযদি `path` এক্সটেনশন `.zip` থাকে, তাহলে `unzip()` প্রসেস করা হয়, এবং এক্সটেনশন `.zip` এর কোন বিবরণ নেই। বিকল্পভাবে, একটি এক্সটেনশন `.zip` থাকলেও, যদি একটি ওয়াইল্ডকার্ড `*` বিবরণ থাকে, `zip()` প্রক্রিয়া করা হবে।\n\n| নামহীন | বর্ণনা                     |\n| ------ | -------------------------- |\n| `1`    | প্রবেশ করতে `path` বা ফাইল |\n| `2`    | ফোল্ডার ফাইল আউটপুট `dest` |\n\n| নাম      | সংক্ষিপ্ত নাম | বর্ণনা                     |\n| -------- | ------------- | -------------------------- |\n| `--path` | `-p`          | প্রবেশ করতে `path` বা ফাইল |\n| `--dest` | `-d`          | ফোল্ডার ফাইল আউটপুট `dest` |\n"
            }
        },
        "# モジュールのバンドル（パッケージ化）とインストール": {
            "content": "# モジュールのバンドル（パッケージ化）とインストール\n\n*wes* ではいくつかのモジュールをバンドルしたものをパッケージといいます。\n*github* で公開されている *wes* 用のパッケージをインストールできます。\nパッケージを公開する為には *github repository* が必要になります。",
            "translated": {
                "en": "# Bundling (packaging) and installing modules\n\nIn *wes* , a bundle of several modules is called a package. You can install the package for *wes* published on *github* . A *github repository* is required to publish a package.\n",
                "zh-CN": "# 捆绑（打包）和安装模块\n\n在*wes*中，几个模块的捆绑称为一个包。您可以安装在*github*上发布的*wes*软件包。发布包需要*github repository* 。\n",
                "zh-TW": "# 捆綁（打包）和安裝模塊\n\n在*wes*中，幾個模塊的捆綁稱為一個包。您可以安裝在*github*上發布的*wes*軟件包。發布包需要*github repository* 。\n",
                "es": "# Agrupación (embalaje) e instalación de módulos\n\nEn *wes* , un conjunto de varios módulos se denomina paquete. Puede instalar el paquete para *wes* publicado en *github* . Se requiere un *github repository* para publicar un paquete.\n",
                "de": "# Bündeln (Verpacken) und Installieren von Modulen\n\nIn *wes* wird ein Bündel aus mehreren Modulen als Paket bezeichnet. Sie können das auf *github* veröffentlichte Paket für *wes* installieren. Zum Veröffentlichen eines Pakets ist ein *github repository* erforderlich.\n",
                "fr": "# Regroupement (conditionnement) et installation de modules\n\nDans *wes* , un bundle de plusieurs modules est appelé un package. Vous pouvez installer le package pour *wes* publié sur *github* . Un *github repository* est requis pour publier un package.\n",
                "hi": "# बंडलिंग (पैकेजिंग) और मॉड्यूल स्थापित करना\n\n*wes* में, कई मॉड्यूल के बंडल को पैकेज कहा जाता है। आप *github* पर प्रकाशित *wes* के लिए पैकेज स्थापित कर सकते हैं। एक पैकेज प्रकाशित करने के लिए एक *github repository* की आवश्यकता होती है।\n",
                "pt": "# Agrupamento (embalagem) e instalação de módulos\n\nEm *wes* , um pacote de vários módulos é chamado de pacote. Você pode instalar o pacote para *wes* publicado no *github* . Um *github repository* é necessário para publicar um pacote.\n",
                "it": "# Raggruppamento (packaging) e installazione di moduli\n\nIn *wes* , un pacchetto di più moduli è chiamato pacchetto. Puoi installare il pacchetto per *wes* pubblicato su *github* . Per pubblicare un pacchetto è necessario un *github repository* .\n",
                "ru": "# Комплектация (упаковка) и установка модулей\n\nВ *wes* пакет из нескольких модулей называется пакетом. Вы можете установить пакет для *wes* , опубликованный на *github* . Для публикации пакета требуется *github repository* .\n",
                "ms": "# Mengikat (pembungkusan) dan memasang modul\n\nDalam *wes* , himpunan beberapa modul dipanggil pakej. Anda boleh memasang pakej untuk *wes* diterbitkan di *github* . *github repository* diperlukan untuk menerbitkan pakej.\n",
                "nl": "# Modules bundelen (verpakken) en installeren\n\nIn *wes* wordt een bundel van meerdere modules een pakket genoemd. U kunt het pakket voor *wes* installeren dat op *github* is gepubliceerd. Een *github repository* is vereist om een ​​pakket te publiceren.\n",
                "ar": "# تجميع (تغليف) وتثبيت الوحدات\n\nفي *wes* ، تسمى حزمة من عدة وحدات حزمة. يمكنك تثبيت الحزمة الخاصة بـ *wes* المنشورة على *github* . مطلوب *github repository* لنشر الحزمة.\n",
                "bn": "# বান্ডলিং (প্যাকেজিং) এবং মডিউল ইনস্টল করা\n\n*wes* এ, বেশ কয়েকটি মডিউলের একটি বান্ডিলকে প্যাকেজ বলা হয়। আপনি *github* এ প্রকাশিত *wes* এর জন্য প্যাকেজটি ইনস্টল করতে পারেন। একটি প্যাকেজ প্রকাশ করার জন্য একটি *github repository* প্রয়োজন।\n"
            }
        },
        "## *bundle*": {
            "content": "## *bundle*\n\n*github* にパッケージを公開するにあたり、*bundle* は必要なモジュールをバンドルし、*bundle.json* を作成します。\n\n1.  １つの *repository* で公開できるパッケージは１つになります\n2.  *package.json* が必須になります。\n    最低限 `main` フィールドの記述が必須です。\n    ```json\n    {\n        \"main\": \"index.js\"\n    }\n    ```\n3.  パッケージを公開する場合はリポジトリを *public* にしてください\n4.  `version 0.12.0` からワーキングディレクトリより上層のディレクトリへの直接的なモジュール読み込みがあるパッケージはバンドル不可になります。上層のディレクトリ *wes\\_modules* もしくは *node\\_modules* にあるパッケージはバンドル可能です。\n\nバンドルするには以下のコマンドを入力します。何をバンドルするかは *package.json* を参照します。\n\n```bat\n    wes bundle \n```",
            "translated": {
                "en": "## *bundle*\n\nWhen publishing a package to *github* , *bundle* bundles the required modules and creates *bundle.json* .\n\n1.  Only one package can be published in one *repository*\n\n2.  *package.json* is required. At a minimum, the description of the `main` field is required.\n\n         { \"main\": \"index.js\" }\n\n3.  Make the repository *public* if you want to publish the package\n\n4.  Starting with `version 0.12.0` , packages with direct module loading into a directory above the working directory will not be bundled. Packages in the upper directory *wes\\_modules* or *node\\_modules* can be bundled.\n\nEnter the following command to bundle: Refer to *package.json* for what to bundle.\n\n     wes bundle\n",
                "zh-CN": "## *bundle*\n\n将包发布到*github*时， *bundle*会捆绑所需的模块并创建*bundle.json* 。\n\n1.  一个*repository*只能发布一个包\n\n2.  *package.json*是必需的。至少， `main`字段的描述是必需的。\n\n         { \"main\": \"index.js\" }\n\n3.  如果要发布包，请*public*存储库\n\n4.  从`version 0.12.0`开始，直接模块加载到工作目录之上的目录的包将不会被捆绑。可以捆绑上层目录*wes\\_modules*或*node\\_modules*中的包。\n\n输入以下命令进行捆绑：请参阅*package.json*以了解要捆绑的内容。\n\n     wes bundle\n",
                "zh-TW": "## *bundle*\n\n將包發佈到*github*時， *bundle*會捆綁所需的模塊並創建*bundle.json* 。\n\n1.  一個*repository*只能發布一個包\n\n2.  *package.json*是必需的。至少， `main`字段的描述是必需的。\n\n         { \"main\": \"index.js\" }\n\n3.  如果要發布包，請*public*存儲庫\n\n4.  從`version 0.12.0`開始，直接模塊加載到工作目錄之上的目錄的包將不會被捆綁。可以捆綁上層目錄*wes\\_modules*或*node\\_modules*中的包。\n\n輸入以下命令進行捆綁：請參閱*package.json*以了解要捆綁的內容。\n\n     wes bundle\n",
                "es": "## *bundle*\n\nAl publicar un paquete en *github* , *bundle* agrupa los módulos necesarios y crea *bundle.json* .\n\n1.  Solo se puede publicar un paquete en un *repository*\n\n2.  Se requiere *package.json* . Como mínimo, se requiere la descripción del campo `main` .\n\n         { \"main\": \"index.js\" }\n\n3.  Haga *public* el repositorio si desea publicar el paquete\n\n4.  A partir de `version 0.12.0` , los paquetes con módulos que se cargan directamente en un directorio por encima del directorio de trabajo no se incluirán. Los paquetes en el directorio superior *wes\\_modules* o *node\\_modules* se pueden agrupar.\n\nIngrese el siguiente comando para agrupar: Consulte *package.json* para saber qué empaquetar.\n\n     wes bundle\n",
                "de": "## *bundle*\n\nBeim Veröffentlichen eines Pakets auf *github* bündelt *bundle* die erforderlichen Module und erstellt *bundle.json* .\n\n1.  In einem *repository* kann nur ein Paket veröffentlicht werden\n\n2.  *package.json* ist erforderlich. Als Minimum ist die Beschreibung des `main` erforderlich.\n\n         { \"main\": \"index.js\" }\n\n3.  Machen Sie das Repository *public* , wenn Sie das Paket veröffentlichen möchten\n\n4.  Ab `version 0.12.0` werden Pakete mit direktem Modulladen in ein Verzeichnis oberhalb des Arbeitsverzeichnisses nicht mehr gebündelt. Pakete im oberen Verzeichnis *wes\\_modules* oder *node\\_modules* können gebündelt werden.\n\nGeben Sie zum Bündeln den folgenden Befehl ein: *package.json* Sie, was gebündelt werden soll.\n\n     wes bundle\n",
                "fr": "## *bundle*\n\nLors de la publication d'un package sur *github* , *bundle* regroupe les modules requis et crée *bundle.json* .\n\n1.  Un seul package peut être publié dans un *repository*\n\n2.  *package.json* est requis. Au minimum, la description du champ `main` est requise.\n\n         { \"main\": \"index.js\" }\n\n3.  Rendez le référentiel *public* si vous souhaitez publier le package\n\n4.  À partir de la `version 0.12.0` , les packages avec chargement direct du module dans un répertoire au-dessus du répertoire de travail ne seront pas regroupés. Les packages du répertoire supérieur *wes\\_modules* ou *node\\_modules* peuvent être regroupés.\n\nSaisissez la commande suivante pour regrouper : Reportez-vous à *package.json* pour savoir quoi regrouper.\n\n     wes bundle\n",
                "hi": "## *bundle*\n\n*github* पर पैकेज प्रकाशित करते समय, *bundle* आवश्यक मॉड्यूल को बंडल करता है और *bundle.json* बनाता है।\n\n1.  एक *repository* में केवल एक पैकेज प्रकाशित किया जा सकता है\n\n2.  *package.json* आवश्यक है। कम से कम, `main` क्षेत्र का विवरण आवश्यक है।\n\n         { \"main\": \"index.js\" }\n\n3.  यदि आप पैकेज प्रकाशित करना चाहते हैं तो रिपॉजिटरी को *public* करें\n\n4.  `version 0.12.0` से शुरू होकर, कार्यशील निर्देशिका के ऊपर एक निर्देशिका में सीधे मॉड्यूल लोड होने वाले पैकेजों को बंडल नहीं किया जाएगा। ऊपरी निर्देशिका में संकुल *wes\\_modules* या *node\\_modules* बंडल किए जा सकते हैं।\n\nबंडल करने के लिए निम्न आदेश दर्ज करें: क्या बंडल करना है इसके लिए *package.json* का संदर्भ लें।\n\n     wes bundle\n",
                "pt": "## *bundle*\n\nAo publicar um pacote no *github* , o *bundle* agrupa os módulos necessários e cria *bundle.json* .\n\n1.  Apenas um pacote pode ser publicado em um *repository*\n\n2.  *package.json* é obrigatório. No mínimo, a descrição do campo `main` é obrigatória.\n\n         { \"main\": \"index.js\" }\n\n3.  Torne o repositório *public* se quiser publicar o pacote\n\n4.  A partir da `version 0.12.0` , os pacotes com carregamento direto do módulo em um diretório acima do diretório de trabalho não serão empacotados. Os pacotes no diretório superior *wes\\_modules* ou *node\\_modules* podem ser agrupados.\n\nDigite o seguinte comando para agrupar: Consulte *package.json* para saber o que agrupar.\n\n     wes bundle\n",
                "it": "## *bundle*\n\nQuando si pubblica un pacchetto su *github* , *bundle* raggruppa i moduli richiesti e crea *bundle.json* .\n\n1.  È possibile pubblicare un solo pacchetto in un *repository*\n\n2.  *package.json* è obbligatorio. Come minimo, è richiesta la descrizione del campo `main` .\n\n         { \"main\": \"index.js\" }\n\n3.  Rendi *public* il repository se desideri pubblicare il pacchetto\n\n4.  A partire dalla `version 0.12.0` , i pacchetti con caricamento diretto del modulo in una directory sopra la directory di lavoro non verranno raggruppati. I pacchetti nella directory superiore *wes\\_modules* o *node\\_modules* possono essere raggruppati.\n\nImmettere il seguente comando per raggruppare: Fare riferimento a *package.json* per cosa raggruppare.\n\n     wes bundle\n",
                "ru": "## *bundle*\n\nПри публикации пакета на *github* *bundle* объединяет необходимые модули и создает *bundle.json* .\n\n1.  Только один пакет может быть опубликован в одном *repository*\n\n2.  требуется *package.json* . Как минимум требуется описание `main` поля.\n\n         { \"main\": \"index.js\" }\n\n3.  Сделайте репозиторий *public* , если хотите опубликовать пакет\n\n4.  Начиная с `version 0.12.0` , пакеты с прямой загрузкой модуля в каталог выше рабочего каталога не будут объединяться. Пакеты в верхнем каталоге *wes\\_modules* или *node\\_modules* могут быть объединены.\n\nВведите следующую команду для объединения: Обратитесь к *package.json* для того, чтобы связать.\n\n     wes bundle\n",
                "ms": "## *bundle*\n\nApabila menerbitkan pakej ke *github* , *bundle* modul yang diperlukan dan mencipta *bundle.json* .\n\n1.  Hanya satu pakej boleh diterbitkan dalam satu *repository*\n\n2.  *package.json* diperlukan. Sekurang-kurangnya, perihalan medan `main` diperlukan.\n\n         { \"main\": \"index.js\" }\n\n3.  Jadikan repositori *public* jika anda ingin menerbitkan pakej tersebut\n\n4.  Bermula dengan `version 0.12.0` , pakej dengan pemuatan modul langsung ke dalam direktori di atas direktori kerja tidak akan digabungkan. Pakej dalam direktori atas *wes\\_modules* atau *node\\_modules* boleh digabungkan.\n\nMasukkan arahan berikut untuk digabungkan: Rujuk *package.json* untuk mengetahui perkara yang hendak digabungkan.\n\n     wes bundle\n",
                "nl": "## *bundle*\n\nBij het publiceren van een pakket naar *github* , *bundle* bundel de vereiste modules en maakt *bundle.json* .\n\n1.  Er kan slechts één pakket in één *repository* worden gepubliceerd\n\n2.  *package.json* is vereist. De beschrijving van het `main` is minimaal vereist.\n\n         { \"main\": \"index.js\" }\n\n3.  Maak de repository *public* als u het pakket wilt publiceren\n\n4.  Vanaf `version 0.12.0` worden pakketten met een directe module die in een map boven de werkmap wordt geladen, niet gebundeld. Pakketten in de bovenste directory *wes\\_modules* of *node\\_modules* kunnen worden gebundeld.\n\nVoer de volgende opdracht in om te bundelen: Raadpleeg *package.json* voor wat u moet bundelen.\n\n     wes bundle\n",
                "ar": "## *bundle*\n\nعند نشر *bundle* على *github* ، قم بتجميع الوحدات النمطية المطلوبة في حزم وإنشاء *bundle.json* .\n\n1.  يمكن نشر حزمة واحدة فقط في *repository* واحد\n\n2.  *package.json* مطلوب. كحد أدنى ، مطلوب وصف الحقل `main` .\n\n         { \"main\": \"index.js\" }\n\n3.  اجعل المستودع *public* إذا كنت تريد نشر الحزمة\n\n4.  بدءًا من `version 0.12.0` ، لن يتم تجميع الحزم ذات التحميل المباشر للوحدة في دليل أعلى دليل العمل. يمكن تجميع الحزم الموجودة في الدليل العلوي *wes\\_modules* أو *node\\_modules* .\n\nأدخل الأمر التالي للحزمة: ارجع إلى *package.json* لمعرفة ما تريد تجميعه.\n\n     wes bundle\n",
                "bn": "## *bundle*\n\n*github* একটি প্যাকেজ প্রকাশ করার সময়, প্রয়োজনীয় মডিউলগুলি *bundle* করে এবং *bundle.json* তৈরি করে।\n\n1.  একটি *repository* শুধুমাত্র একটি প্যাকেজ প্রকাশ করা যেতে পারে\n\n2.  *package.json* প্রয়োজন। ন্যূনতম, `main` ক্ষেত্রের বিবরণ প্রয়োজন।\n\n         { \"main\": \"index.js\" }\n\n3.  আপনি যদি প্যাকেজটি প্রকাশ করতে চান তাহলে সংগ্রহস্থলটিকে *public* করুন৷\n\n4.  `version 0.12.0` দিয়ে শুরু করে, কার্যকারী ডিরেক্টরির উপরে একটি ডিরেক্টরিতে সরাসরি মডিউল লোড করা প্যাকেজগুলি বান্ডিল করা হবে না। উপরের ডিরেক্টরির *wes\\_modules* বা *node\\_modules* করা যেতে পারে।\n\nবান্ডিল করতে নিম্নলিখিত কমান্ডটি লিখুন: কি বান্ডেল করতে হবে তা জানতে *package.json* পড়ুন।\n\n     wes bundle\n"
            }
        },
        "## *install*": {
            "content": "## *install*\n\n*github* に公開されている *wes* 用のパッケージをインストールするのに使用します。\n`version 0.10.28` からインストールフォルダが `node_modules` から `wes_modules` に変更になります。\n`node_modules` にインストールする場合は、`--node` オプションを追加してください。\n`version 0.12.0` からファイルを *bandle.json* から解凍して保存するようになります。仕様変更の為 `version 0.12.0` 未満でバンドルされたパッケージは `version 0.12.0` 以降では正しくインストールされない場合があります。\n\n### 使い方\n\n*install* には `@author/repository` という書式で引数を渡します。\n\n```bat\nwes install @wachaon/fmt\n```\n\n*install* にはオプションがあります。\n\n| named         | short named | Description                                                |\n| ------------- | ----------- | ---------------------------------------------------------- |\n| `--bare`      | `-b`        | *@author* フォルダを作成しない                                       |\n| `--global`    | `-g`        | *wes.js* があるフォルダにパッケージをインストールする                            |\n| `--save`      | `-S`        | *package.json* の *dependencies* フィールドにパッケージ名とバージョンを追加する    |\n| `--save--dev` | `-D`        | *package.json* の *devDependencies* フィールドにパッケージ名とバージョンを追加する |\n| `--node`      | `-n`        | *node\\_module* フォルダにインストールする                               |\n\n`--bare` オプションは `require` の引数を `author@repository` から `repository` に省略できます。\n`--global` オプションはインストールしたパッケージを全てのスクリプトから利用できます。\n\n```bat\nwes install @wachaon/fmt --bare\n```",
            "translated": {
                "en": "undefined\n",
                "zh-CN": "undefined\n",
                "zh-TW": "undefined\n",
                "es": "undefined\n",
                "de": "undefined\n",
                "fr": "undefined\n",
                "hi": "undefined\n",
                "pt": "undefined\n",
                "it": "undefined\n",
                "ru": "undefined\n",
                "ms": "undefined\n",
                "nl": "undefined\n",
                "ar": "undefined\n",
                "bn": "undefined\n"
            }
        },
        "# プライベートリポジトリにあるパッケージのインストール": {
            "content": "# プライベートリポジトリにあるパッケージのインストール\n\n*install* は *github* のパブリックリポジトリのパッケージだけでなく、プライベートリポジトリのパッケージもインストールできます。\n*install* では *@author/repository* でパッケージを指定します。\n実装では下記 url のダウンロードを試みます。\n\n```javascript\n`https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n```\n\nブラウザでプライベートリポジトリの *raw* にアクセスすると *token* が表示されますので、\nその *token* をコピーして使用します。\n*token* の有効時間内にコンソールで実行すれば、プライベートリポジトリのパッケージもインストールできます。\n\n```bat\nwes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n```",
            "translated": {
                "en": "# Installing packages from private repositories\n\n*install* can install not only packages from public *github* repositories, but also packages from private repositories. In *install* , specify the package with *@author/repository* . The implementation tries to download the following url.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nIf you access the private repository *raw* with a browser, the *token* will be displayed, so copy the *token* and use it. You can also install packages from private repositories by running it in the console while the *token* is valid.\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "zh-CN": "# 从私有仓库安装包\n\n*install*不仅可以安装来自公共*github*存储库的包，还可以安装来自私有存储库的包。在*install*中，使用*@author/repository*指定包。该实现尝试下载以下 url。\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\n如果您使用浏览器访问*raw*存储库，则会显示*token* ，因此请复制*token*并使用它。您还可以通过在*token*有效时在控制台中运行来安装私有存储库中的软件包。\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "zh-TW": "# 從私有倉庫安裝包\n\n*install*不僅可以安裝來自公共*github*存儲庫的包，還可以安裝來自私有存儲庫的包。在*install*中，使用*@author/repository*指定包。該實現嘗試下載以下 url。\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\n如果您使用瀏覽器訪問*raw*存儲庫，則會顯示*token* ，因此請複制*token*並使用它。您還可以通過在*token*有效時在控制台中運行來安裝私有存儲庫中的軟件包。\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "es": "# Instalar paquetes desde repositorios privados\n\n*install* puede instalar no solo paquetes de repositorios públicos de *github* , sino también paquetes de repositorios privados. En la *install* , especifique el paquete con *@author/repository* . La implementación intenta descargar la siguiente url.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nSi accede al repositorio privado *raw* con un navegador, se mostrará el *token* , así que copie el *token* y utilícelo. También puede instalar paquetes desde repositorios privados ejecutándolos en la consola mientras el *token* es válido.\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "de": "# Installieren von Paketen aus privaten Repositories\n\n*install* kann nicht nur Pakete aus öffentlichen *github* Repositories installieren, sondern auch Pakete aus privaten Repositories. Geben Sie bei *install* das Paket mit *@author/repository* an. Die Implementierung versucht, die folgende URL herunterzuladen.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nWenn Sie mit einem Browser *raw* auf das private Repository zugreifen, wird das *token* angezeigt, also kopieren Sie das *token* und verwenden Sie es. Sie können auch Pakete aus privaten Repositorys installieren, indem Sie sie in der Konsole ausführen, solange das *token* gültig ist.\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "fr": "# Installation de packages à partir de référentiels privés\n\n*install* peut installer non seulement des packages à partir de référentiels *github* publics, mais également des packages à partir de référentiels privés. Dans *install* , spécifiez le package avec *@author/repository* . L'implémentation tente de télécharger l'URL suivante.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nLorsque vous accédez au *raw* du référentiel privé avec un navigateur, le *token* s'affiche, alors copiez le *token* et utilisez-le. Les packages provenant de référentiels privés peuvent également être installés s'ils sont exécutés dans la console pendant que le *token* est valide.\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "hi": "# निजी भंडारों से संकुल अधिष्ठापन\n\n*install* न केवल सार्वजनिक *github* रिपॉजिटरी से पैकेज स्थापित कर सकता है, बल्कि निजी रिपॉजिटरी से भी पैकेज स्थापित कर सकता है। *install* में, पैकेज को *@author/repository* के साथ निर्दिष्ट करें। कार्यान्वयन निम्न url को डाउनलोड करने का प्रयास करता है।\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nयदि आप एक ब्राउज़र के साथ निजी भंडार तक *raw* हैं, तो *token* प्रदर्शित होगा, इसलिए *token* की प्रतिलिपि बनाएँ और उसका उपयोग करें। आप निजी रिपॉजिटरी से पैकेज को कंसोल में चलाकर भी इंस्टॉल कर सकते हैं जबकि *token* वैध है।\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "pt": "# Instalando pacotes de repositórios privados\n\n*install* pode instalar não apenas pacotes de repositórios *github* públicos, mas também pacotes de repositórios privados. Em *install* , especifique o pacote com *@author/repository* . A implementação tenta baixar o seguinte URL.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nSe você acessar o repositório privado *raw* com um navegador, o *token* será exibido, então copie o *token* e use-o. Você também pode instalar pacotes de repositórios privados executando-o no console enquanto o *token* é válido.\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "it": "# Installazione di pacchetti da repository privati\n\n*install* può installare non solo pacchetti da repository *github* pubblici, ma anche pacchetti da repository privati. In *install* , specifica il pacchetto con *@author/repository* . L'implementazione tenta di scaricare il seguente URL.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nSe accedi al repository privato *raw* con un browser, il *token* verrà visualizzato, quindi copia il *token* e usalo. Puoi anche installare pacchetti da repository privati ​​eseguendolo nella console mentre il *token* è valido.\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "ru": "# Установка пакетов из приватных репозиториев\n\n*install* может устанавливать не только пакеты из общедоступных репозиториев *github* , но и пакеты из частных репозиториев. В *install* укажите пакет с помощью *@author/repository* . Реализация пытается загрузить следующий URL-адрес.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nЕсли вы получаете доступ к частному *raw* через браузер, *token* будет отображаться, поэтому скопируйте *token* и используйте его. Вы также можете установить пакеты из частных репозиториев, запустив их в консоли, пока *token* действителен.\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "ms": "# Memasang pakej dari repositori peribadi\n\n*install* boleh memasang bukan sahaja pakej dari repositori *github* awam, tetapi juga pakej dari repositori peribadi. Dalam *install* , nyatakan pakej dengan *@author/repository* . Pelaksanaan cuba memuat turun url berikut.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nJika anda mengakses repositori persendirian *raw* dengan penyemak imbas, *token* akan dipaparkan, jadi salin *token* dan gunakannya. Anda juga boleh memasang pakej dari repositori peribadi dengan menjalankannya dalam konsol semasa *token* itu sah.\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "nl": "# Pakketten installeren vanuit privé-repository's\n\n*install* kan niet alleen pakketten van openbare *github* repositories installeren, maar ook pakketten van private repositories. Geef in *install* het pakket op met *@author/repository* . De implementatie probeert de volgende url te downloaden.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nAls u de private repository *raw* met een browser, wordt het *token* weergegeven, dus kopieer het *token* en gebruik het. U kunt ook pakketten installeren vanuit privérepository's door het in de console uit te voeren terwijl het *token* geldig is.\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "ar": "# تركيب الحزم من المستودعات الخاصة\n\nيمكن *install* ليس فقط تثبيت الحزم من مستودعات *github* العامة ، ولكن أيضًا الحزم من المستودعات الخاصة. في *install* ، حدد الحزمة مع *@author/repository* . يحاول التنفيذ تنزيل عنوان url التالي.\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nإذا قمت بالوصول إلى المستودع الخاص بشكل *raw* باستخدام متصفح ، فسيتم عرض *token* ، لذا انسخ *token* . يمكنك أيضًا تثبيت الحزم من المستودعات الخاصة عن طريق تشغيلها في وحدة التحكم أثناء صلاحية *token* .\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n",
                "bn": "# ব্যক্তিগত সংগ্রহস্থল থেকে প্যাকেজ ইনস্টল করা হচ্ছে\n\n*install* শুধুমাত্র পাবলিক *github* রিপোজিটরি থেকে প্যাকেজ ইন্সটল করতে পারে না, ব্যক্তিগত রিপোজিটরি থেকে প্যাকেজও ইনস্টল করতে পারে। *install* , *@author/repository* সহ প্যাকেজটি নির্দিষ্ট করুন। বাস্তবায়ন নিম্নলিখিত url ডাউনলোড করার চেষ্টা করে।\n\n     `https://raw.githubusercontent.com/${author}/${repository}/master/bundle.json`\n\nআপনি যখন ব্রাউজার দিয়ে ব্যক্তিগত সংগ্রহস্থলের *raw* অ্যাক্সেস করেন, *token* প্রদর্শিত হবে, তাই *token* অনুলিপি করুন এবং এটি ব্যবহার করুন। *token* বৈধ থাকাকালীন কনসোলে কার্যকর করা হলে ব্যক্তিগত সংগ্রহস্থল থেকে প্যাকেজগুলিও ইনস্টল করা যেতে পারে।\n\n     wes install @wachaon/calc?token=ADAAOIID5JALCLECFVLWV7K6ZHHDA\n"
            }
        },
        "# パッケージの紹介": {
            "content": "# パッケージの紹介\n\nここではいくつかの外部パッケージを紹介します。",
            "translated": {
                "en": "# Package introduction\n\nHere are some external packages.\n",
                "zh-CN": "# 包装介绍\n\n这是一些外部软件包。\n",
                "zh-TW": "# 包裝介紹\n\n這是一些外部軟件包。\n",
                "es": "# Introducción del paquete\n\nAquí hay algunos paquetes externos.\n",
                "de": "# Paket Einführung\n\nHier sind einige externe Pakete.\n",
                "fr": "# Présentation du paquet\n\nVoici quelques packages externes.\n",
                "hi": "# पैकेज परिचय\n\nयहां कुछ बाहरी पैकेज दिए गए हैं।\n",
                "pt": "# Introdução do pacote\n\nAqui estão alguns pacotes externos.\n",
                "it": "# Presentazione del pacchetto\n\nEcco alcuni pacchetti esterni.\n",
                "ru": "# Введение пакета\n\nВот несколько внешних пакетов.\n",
                "ms": "# Pengenalan pakej\n\nBerikut adalah beberapa pakej luaran.\n",
                "nl": "# Pakket introductie:\n\nHier zijn enkele externe pakketten.\n",
                "ar": "# مقدمة الحزمة\n\nفيما يلي بعض الحزم الخارجية.\n",
                "bn": "# প্যাকেজ পরিচিতি\n\nএখানে কিছু বাহ্যিক প্যাকেজ আছে.\n"
            }
        },
        "## *@wachaon/fmt*": {
            "content": "## *@wachaon/fmt*\n\n*@wachaon/fmt* は *prettier* を *wes* 用にパッケージ化したもので、スクリプトのフォーマットをします。\nまた、*@wachaon/fmt* がインストールされている状態で *Syntax Error* が発生した場合に\nそのエラー箇所を提示できます。\n\n### インストール\n\n```bat\nwes install @wachaon/fmt\n```\n\n### 使い方\n\nワーキングディレクトリに *.prettierrc* (JSON フォーマット) があれば設定に反映させます。\n*fmt* は *CLI* と *module* の両方で使用できます。\n\n#### *CLI* として使用する。\n\n```bat\nwes @wachaon/fmt src/sample --write\n```\n\n| unnamed number | Description         |\n| -------------- | ------------------- |\n| 1              | 必須。フォーマットしたいファイルのパス |\n\n| named     | short named | Description |\n| --------- | ----------- | ----------- |\n| `--write` | `-w`        | 上書きを許可する    |\n\n`--write` もしくは `-w` の名前付き引数の指定があればフォーマットしたスクリプトでファイルを上書きします。\n\n#### モジュールとして使用する\n\n```javascript\nconst fmt = require('@wachaon/fmt')\nconst { readTextFileSync, writeTextFileSync } = require('filesystem')\nconst { join, workingDirectory } = require('pathname')\nconst target = join(workingDirectory, 'index.js')\nconsole.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n```",
            "translated": {
                "en": "## *@wachaon/fmt*\n\n*@wachaon/fmt* is *prettier* packaged for *wes* to format scripts. Also, if a *Syntax Error* occurs while *@wachaon/fmt* is installed, you can indicate the location of the error.\n\n### install\n\n     wes install @wachaon/fmt\n\n### Usage\n\nIf there is *.prettierrc* (JSON format) in the working directory, it will be reflected in the settings. *fmt* is available in both *CLI* and *module* .\n\n#### Use as *CLI* .\n\n     wes @wachaon/fmt src/sample --write\n\n| unnamed number | Description                                       |\n| -------------- | ------------------------------------------------- |\n| 1              | Required. the path of the file you want to format |\n\n| named     | short named | Description     |\n| --------- | ----------- | --------------- |\n| `--write` | `-w`        | allow overwrite |\n\nOverwrite the file with the formatted script if `--write` or the `-w` named argument is specified.\n\n#### use as a module\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "zh-CN": "## *@wachaon/fmt*\n\n*@wachaon/fmt* *prettier*地打包为*wes*格式化脚本。此外，如果在安装*@wachaon/fmt*时出现*Syntax Error* ，您可以指出错误的位置。\n\n### 安装\n\n    wes install @wachaon/fmt\n\n### 用法\n\n如果工作目录中有*.prettierrc* （JSON 格式），它会反映在设置中。 *fmt*在*CLI*和*module*中都可用。\n\n#### 用作*CLI* 。\n\n     wes @wachaon/fmt src/sample --write\n\n| 无名号码 | 描述             |\n| ---- | -------------- |\n| 1    | 必需的。要格式化的文件的路径 |\n\n| 命名为       | 简称   | 描述   |\n| --------- | ---- | ---- |\n| `--write` | `-w` | 允许覆盖 |\n\n如果指定了`--write`或`-w`命名参数，则使用格式化脚本覆盖文件。\n\n#### 作为一个模块使用\n\n    const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "zh-TW": "## *@wachaon/fmt*\n\n*@wachaon/fmt* *prettier*地打包為*wes*格式化腳本。此外，如果在安裝*@wachaon/fmt*時出現*Syntax Error* ，您可以指出錯誤的位置。\n\n### 安裝\n\n    wes install @wachaon/fmt\n\n### 用法\n\n如果工作目錄中有*.prettierrc* （JSON 格式），它會反映在設置中。 *fmt*在*CLI*和*module*中都可用。\n\n#### 用作*CLI* 。\n\n     wes @wachaon/fmt src/sample --write\n\n| 無名號碼 | 描述             |\n| ---- | -------------- |\n| 1    | 必需的。要格式化的文件的路徑 |\n\n| 命名為       | 簡稱   | 描述   |\n| --------- | ---- | ---- |\n| `--write` | `-w` | 允許覆蓋 |\n\n如果指定了`--write`或`-w`命名參數，則使用格式化腳本覆蓋文件。\n\n#### 作為一個模塊使用\n\n    const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "es": "## *@wachaon/fmt*\n\n*@wachaon/fmt* *prettier* mejor empaquetado para que *wes* forme scripts. Además, si se produce un *Syntax Error* mientras está instalado *@wachaon/fmt* , puede indicar la ubicación del error.\n\n### Instalar en pc\n\n     wes install @wachaon/fmt\n\n### Uso\n\nSi hay *.prettierrc* (formato JSON) en el directorio de trabajo, se reflejará en la configuración. *fmt* está disponible tanto en *CLI* como en *module* .\n\n#### Utilizar como *CLI* .\n\n     wes @wachaon/fmt src/sample --write\n\n| número sin nombre | Descripción                                        |\n| ----------------- | -------------------------------------------------- |\n| 1                 | Requerido. la ruta del archivo que desea formatear |\n\n| nombrada  | nombre corto | Descripción           |\n| --------- | ------------ | --------------------- |\n| `--write` | `-w`         | permitir sobrescribir |\n\nSobrescriba el archivo con el script formateado si se `--write` o el argumento con nombre `-w` .\n\n#### utilizar como módulo\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "de": "## *@wachaon/fmt*\n\n*@wachaon/fmt* ist *prettier* verpackt, damit *wes* Skripte formatieren können. Wenn während der Installation von *@wachaon/fmt* ein *Syntax Error* auftritt, können Sie außerdem den Ort des Fehlers angeben.\n\n### Installieren\n\n     wes install @wachaon/fmt\n\n### Verwendungszweck\n\nWenn im Arbeitsverzeichnis *.prettierrc* (JSON-Format) vorhanden ist, wird dies in den Einstellungen widergespiegelt. *fmt* ist sowohl im *CLI* als auch im *module* verfügbar.\n\n#### Als *CLI* verwenden.\n\n     wes @wachaon/fmt src/sample --write\n\n| unbenannte Nummer | Beschreibung                                                  |\n| ----------------- | ------------------------------------------------------------- |\n| 1                 | Erforderlich. den Pfad der Datei, die Sie formatieren möchten |\n\n| genannt   | kurz benannt | Beschreibung           |\n| --------- | ------------ | ---------------------- |\n| `--write` | `-w`         | Überschreiben zulassen |\n\nÜberschreiben Sie die Datei mit dem formatierten Skript, wenn `--write` oder das benannte Argument `-w` angegeben ist.\n\n#### als Modul verwenden\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "fr": "## *@wachaon/fmt*\n\n*@wachaon/fmt* est *prettier* emballé pour *wes* pour formater les scripts. De même, si une *Syntax Error* se produit lors *@wachaon/fmt* , vous pouvez indiquer l'emplacement de l'erreur.\n\n### installer\n\n     wes install @wachaon/fmt\n\n### Usage\n\nS'il y a *.prettierrc* (format JSON) dans le répertoire de travail, cela sera reflété dans les paramètres. *fmt* est disponible à la fois dans la *CLI* et dans le *module* .\n\n#### Utiliser comme *CLI* .\n\n     wes @wachaon/fmt src/sample --write\n\n| numéro anonyme | La description                                                |\n| -------------- | ------------------------------------------------------------- |\n| 1              | Obligatoire. le chemin du fichier que vous souhaitez formater |\n\n| nommé     | nommé court | La description            |\n| --------- | ----------- | ------------------------- |\n| `--write` | `-w`        | autoriser le remplacement |\n\nRemplacez le fichier par le script formaté si `--write` ou l'argument nommé `-w` est spécifié.\n\n#### utiliser comme module\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "hi": "## *@wachaon/fmt*\n\nस्क्रिप्ट को प्रारूपित करने के लिए *@wachaon/fmt* को *wes* के लिए *prettier* पैक किया गया है। साथ ही, यदि *@wachaon/fmt* स्थापित होने के दौरान *Syntax Error* होती है, तो आप त्रुटि के स्थान को इंगित कर सकते हैं।\n\n### इंस्टॉल\n\n     wes install @wachaon/fmt\n\n### प्रयोग\n\nयदि कार्यशील निर्देशिका में *.prettierrc* (JSON प्रारूप) है, तो यह सेटिंग्स में दिखाई देगा। *fmt* *CLI* और *module* दोनों में उपलब्ध है।\n\n#### *CLI* के रूप में प्रयोग करें।\n\n     wes @wachaon/fmt src/sample --write\n\n| अनाम संख्या | विवरण                                                |\n| ----------- | ---------------------------------------------------- |\n| 1           | आवश्यक। फ़ाइल का पथ जिसे आप प्रारूपित करना चाहते हैं |\n\n| नामित     | संक्षिप्त नाम | विवरण                       |\n| --------- | ------------- | --------------------------- |\n| `--write` | `-w`          | अधिलेखित करने की अनुमति दें |\n\nप्रारूपित स्क्रिप्ट के साथ फ़ाइल को अधिलेखित करें यदि `--write` या `-w` नामित तर्क निर्दिष्ट है।\n\n#### मॉड्यूल के रूप में उपयोग करें\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "pt": "## *@wachaon/fmt*\n\n*@wachaon/fmt* é um pacote *prettier* para o *wes* formatar scripts. Além disso, se ocorrer um *Syntax Error* enquanto *@wachaon/fmt* estiver instalado, você poderá mostrar o local do erro.\n\n### instalar\n\n     wes install @wachaon/fmt\n\n### Uso\n\nSe houver *.prettierrc* (formato JSON) no diretório de trabalho, isso será refletido nas configurações. *fmt* está disponível na *CLI* e no *module* .\n\n#### Use como *CLI* .\n\n     wes @wachaon/fmt src/sample --write\n\n| número sem nome | Descrição                                                 |\n| --------------- | --------------------------------------------------------- |\n| 1               | Requeridos. o caminho do arquivo que você deseja formatar |\n\n| nomeado   | nome curto | Descrição             |\n| --------- | ---------- | --------------------- |\n| `--write` | `-w`       | permitir sobrescrever |\n\nSobrescreva o arquivo com o script formatado se `--write` ou `-w` o argumento nomeado for especificado.\n\n#### usar como módulo\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "it": "## *@wachaon/fmt*\n\n*@wachaon/fmt* è un pacchetto *prettier* *wes* per noi per formattare gli script. Inoltre, se si verifica un *Syntax Error* durante l'installazione di *@wachaon/fmt* , è possibile indicare la posizione dell'errore.\n\n### installare\n\n     wes install @wachaon/fmt\n\n### Utilizzo\n\nSe è presente *.prettierrc* (formato JSON) nella directory di lavoro, si rifletterà nelle impostazioni. *fmt* è disponibile sia in *CLI* che in *module* .\n\n#### Utilizzare come *CLI* .\n\n     wes @wachaon/fmt src/sample --write\n\n| numero senza nome | Descrizione                                          |\n| ----------------- | ---------------------------------------------------- |\n| 1                 | Necessario. il percorso del file che vuoi formattare |\n\n| di nome   | nome breve | Descrizione                  |\n| --------- | ---------- | ---------------------------- |\n| `--write` | `-w`       | consentire la sovrascrittura |\n\nSovrascrivi il file con lo script formattato se è specificato `--write` o l'argomento denominato `-w` .\n\n#### utilizzare come modulo\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "ru": "## *@wachaon/fmt*\n\n*@wachaon/fmt* *wes* *prettier* форматировать скрипты. Кроме того, если во время *@wachaon/fmt* возникает *Syntax Error* , вы можете указать ее местонахождение.\n\n### установить\n\n     wes install @wachaon/fmt\n\n### Применение\n\nЕсли в рабочей директории есть *.prettierrc* (формат JSON), это будет отражено в настройках. *fmt* доступен как в *CLI* , так и в *module* .\n\n#### Использовать как *CLI* .\n\n     wes @wachaon/fmt src/sample --write\n\n| безымянный номер | Описание                                                     |\n| ---------------- | ------------------------------------------------------------ |\n| 1                | Необходимый. путь к файлу, который вы хотите отформатировать |\n\n| названный | короткое имя | Описание             |\n| --------- | ------------ | -------------------- |\n| `--write` | `-w`         | разрешить перезапись |\n\nПерезапишите файл отформатированным сценарием, если указан аргумент `--write` или `-w` .\n\n#### использовать как модуль\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "ms": "## *@wachaon/fmt*\n\n*@wachaon/fmt* dibungkus *prettier* untuk *wes* memformat skrip. Selain itu, jika *Syntax Error* berlaku semasa *@wachaon/fmt* dipasang, anda boleh menunjukkan lokasi ralat.\n\n### pasang\n\n     wes install @wachaon/fmt\n\n### Penggunaan\n\nJika terdapat *.prettierrc* (format JSON) dalam direktori kerja, ia akan ditunjukkan dalam tetapan. *fmt* tersedia dalam kedua-dua *CLI* dan *module* .\n\n#### Gunakan sebagai *CLI* .\n\n     wes @wachaon/fmt src/sample --write\n\n| nombor tanpa nama | Penerangan                                        |\n| ----------------- | ------------------------------------------------- |\n| 1                 | Diperlukan. laluan fail yang ingin anda formatkan |\n\n| bernama   | pendek bernama | Penerangan           |\n| --------- | -------------- | -------------------- |\n| `--write` | `-w`           | benarkan tulis ganti |\n\nTulis ganti fail dengan skrip terformat jika `--write` atau argumen bernama `-w` ditentukan.\n\n#### digunakan sebagai modul\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "nl": "## *@wachaon/fmt*\n\n*@wachaon/fmt* is *prettier* verpakt voor *wes* om scripts te formatteren. Als er een *Syntax Error* optreedt terwijl *@wachaon/fmt* is geïnstalleerd, kunt u ook de locatie van de fout aangeven.\n\n### installeren\n\n     wes install @wachaon/fmt\n\n### Gebruik\n\nAls er *.prettierrc* (JSON-indeling) in de werkmap staat, wordt dit weergegeven in de instellingen. *fmt* is beschikbaar in zowel *CLI* als *module* .\n\n#### Gebruik als *CLI* .\n\n     wes @wachaon/fmt src/sample --write\n\n| naamloos nummer | Beschrijving                                              |\n| --------------- | --------------------------------------------------------- |\n| 1               | Verplicht. het pad van het bestand dat u wilt formatteren |\n\n| genaamd   | korte naam | Beschrijving           |\n| --------- | ---------- | ---------------------- |\n| `--write` | `-w`       | overschrijven toestaan |\n\nOverschrijf het bestand met het opgemaakte script als `--write` of het `-w` benoemde argument is opgegeven.\n\n#### gebruik als een module\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "ar": "## *@wachaon/fmt*\n\n*@wachaon/fmt* *wes* *prettier* من أجل تنسيق البرامج النصية. أيضًا ، في حالة حدوث *Syntax Error* أثناء *@wachaon/fmt* ، يمكنك الإشارة إلى موقع الخطأ.\n\n### تثبيت\n\n     wes install @wachaon/fmt\n\n### إستعمال\n\nإذا كان هناك تنسيق *.prettierrc* (تنسيق JSON) في دليل العمل ، فسوف ينعكس في الإعدادات. يتوفر *fmt* في كل من *CLI* *module* .\n\n#### استخدام *CLI* .\n\n     wes @wachaon/fmt src/sample --write\n\n| رقم غير مسمى | وصف                                |\n| ------------ | ---------------------------------- |\n| 1            | مطلوب. مسار الملف الذي تريد تنسيقه |\n\n| اسم الشيئ | اسم قصير | وصف             |\n| --------- | -------- | --------------- |\n| `--write` | `-w`     | السماح بالكتابة |\n\nالكتابة فوق الملف باستخدام البرنامج النصي المنسق إذا تم تحديد الوسيطة `--write` أو `-w` المسماة.\n\n#### استخدام كوحدة نمطية\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n",
                "bn": "## *@wachaon/fmt*\n\n*@wachaon/fmt* স্ক্রিপ্ট ফর্ম্যাট করার জন্য *prettier* এর জন্য *wes* প্যাকেজ। এছাড়াও, যদি *@wachaon/fmt* ইনস্টল করার সময় একটি *Syntax Error* ঘটে, আপনি ত্রুটিটির অবস্থান নির্দেশ করতে পারেন।\n\n### ইনস্টল\n\n     wes install @wachaon/fmt\n\n### ব্যবহার\n\nযদি ওয়ার্কিং ডিরেক্টরিতে *.prettierrc* (JSON ফরম্যাট) থাকে তবে সেটি সেটিংসে প্রতিফলিত হবে। *fmt* *CLI* এবং *module* উভয়েই উপলব্ধ।\n\n#### *CLI* হিসাবে ব্যবহার করুন।\n\n     wes @wachaon/fmt src/sample --write\n\n| নামহীন সংখ্যা | বর্ণনা                                            |\n| ------------- | ------------------------------------------------- |\n| 1             | প্রয়োজন। আপনি যে ফাইলটি ফরম্যাট করতে চান তার পাথ |\n\n| নাম       | সংক্ষিপ্ত নাম | বর্ণনা                   |\n| --------- | ------------- | ------------------------ |\n| `--write` | `-w`          | ওভাররাইট করার অনুমতি দিন |\n\n`--write` বা `-w` নামের আর্গুমেন্ট নির্দিষ্ট করা থাকলে ফরম্যাট করা স্ক্রিপ্ট দিয়ে ফাইলটি ওভাররাইট করুন।\n\n#### একটি মডিউল হিসাবে ব্যবহার করুন\n\n     const fmt = require('@wachaon/fmt') const { readTextFileSync, writeTextFileSync } = require('filesystem') const { join, workingDirectory } = require('pathname') const target = join(workingDirectory, 'index.js') console.log(writeTextFileSync(target, fmt.format(readTextFileSync(target))))\n"
            }
        }
    }
}
